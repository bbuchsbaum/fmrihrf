---
title: "Advanced HRF Modeling and Design"
author: "Bradley R. Buchsbaum"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Advanced HRF Modeling and Design}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7, 
  fig.height = 5,
  message = FALSE,
  warning = FALSE
)
library(fmrihrf)
library(dplyr)
library(ggplot2)
library(tidyr)
library(Matrix)
library(viridis)
```

## Introduction

This vignette explores advanced features of `fmrihrf` for systematic HRF modeling, regularization, and experimental design. We'll cover five key functions that extend the basic HRF framework:

- **`hrf_library()`**: Creating systematic collections of HRF variants
- **`penalty_matrix()`**: Regularization matrices for stable HRF estimation  
- **`reconstruction_matrix()`**: Converting basis coefficients back to HRF shapes
- **`regressor_set()`**: Managing multi-condition experimental designs
- **`regressor_design()`**: Building design matrices for complex experimental blocks

These tools are essential for advanced fMRI modeling where you need flexibility in HRF specification, robust estimation with limited data, or complex experimental designs.

## HRF Libraries: Systematic Parameter Exploration

The `hrf_library()` function creates collections of HRF variants by systematically varying parameters. This is useful for exploring how different HRF assumptions affect your model or for building data-driven HRF basis sets.

### Example 1: Library of Gamma HRFs

Let's create a library of gamma HRFs with different shape and rate parameters:

```{r gamma_library}
# Define parameter grid for gamma HRFs
gamma_params <- expand.grid(
  shape = c(4, 6, 8),
  rate = c(0.8, 1.0, 1.2)
)
print(gamma_params)

# Create a generator function for gamma HRFs
make_gamma_hrf <- function(shape, rate) {
  gen_hrf(hrf_gamma, shape = shape, rate = rate, name = paste0("Gamma_", shape, "_", rate))
}

# Create HRF library
gamma_lib <- hrf_library(make_gamma_hrf, gamma_params)
print(gamma_lib)
nbasis(gamma_lib) # 9 HRFs total (3 x 3 grid)

# Evaluate and visualize
time_points <- seq(0, 20, by = 0.1)
gamma_responses <- gamma_lib(time_points)

# Convert to long format for plotting
gamma_df <- as.data.frame(gamma_responses)
names(gamma_df) <- paste0("Shape", gamma_params$shape, "_Rate", gamma_params$rate)
gamma_df$Time <- time_points

gamma_long <- pivot_longer(gamma_df, -Time, names_to = "Parameters", values_to = "Response")

# Create a more informative plot
ggplot(gamma_long, aes(x = Time, y = Response, color = Parameters)) +
  geom_line(linewidth = 1) +
  scale_color_viridis_d() +
  labs(title = "Library of Gamma HRFs",
       subtitle = "Systematic variation of shape and rate parameters",
       x = "Time (seconds)",
       y = "HRF Response") +
  theme_minimal() +
  theme(legend.position = "right")
```

### Example 2: Library of Lagged SPM HRFs

Here's how to create a library of the SPM canonical HRF with different temporal lags:

```{r spm_lag_library}
# Parameter grid for temporal lags
lag_params <- data.frame(lag = seq(-2, 4, by = 1))
print(lag_params)

# Create library using a helper function that applies lag_hrf
create_lagged_spm <- function(lag) {
  lag_hrf(HRF_SPMG1, lag = lag)
}

spm_lag_lib <- hrf_library(create_lagged_spm, lag_params)
print(spm_lag_lib)

# Evaluate and plot
spm_lag_responses <- spm_lag_lib(time_points)
spm_lag_df <- as.data.frame(spm_lag_responses)
names(spm_lag_df) <- paste0("Lag_", lag_params$lag, "s")
spm_lag_df$Time <- time_points

spm_lag_long <- pivot_longer(spm_lag_df, -Time, names_to = "Lag", values_to = "Response")

ggplot(spm_lag_long, aes(x = Time, y = Response, color = Lag)) +
  geom_line(linewidth = 1) +
  scale_color_viridis_d() +
  labs(title = "Library of Lagged SPM Canonical HRFs",
       subtitle = "Temporal lags from -2 to +4 seconds",
       x = "Time (seconds)",
       y = "HRF Response") +
  theme_minimal()
```

## Penalty Matrices: Regularizing HRF Estimation

When estimating HRF shapes from data, especially with flexible basis sets, regularization is crucial to prevent overfitting. The `penalty_matrix()` function encodes prior knowledge about plausible HRF shapes through different types of smoothness constraints.

### Understanding Penalty Matrix Structure

Currently, `penalty_matrix()` returns identity matrices for most HRF types, implementing only ridge (L2) penalties. Let's examine what it actually produces:

```{r penalty_matrices}
# Create different basis types
fir_basis <- gen_hrf(hrf_bspline, N = 8, degree = 1, span = 24, name = "FIR-8")
bspline_basis <- gen_hrf(hrf_bspline, N = 6, degree = 3, span = 24, name = "B-spline-6")

# Check what penalty matrices we actually get
penalty_fir <- penalty_matrix(fir_basis, order = 2)
penalty_bspline <- penalty_matrix(bspline_basis, order = 2)
penalty_spm <- penalty_matrix(HRF_SPMG3, order = 2)

# Visualize the actual penalty matrices
par(mfrow = c(1, 3))

# FIR penalty (should be identity matrix)
image(as.matrix(penalty_fir), main = "FIR Penalty Matrix\n(Currently: Identity)", 
      xlab = "Basis", ylab = "Basis", col = heat.colors(20))

# B-spline penalty (also identity)
image(as.matrix(penalty_bspline), main = "B-spline Penalty Matrix\n(Currently: Identity)", 
      xlab = "Basis", ylab = "Basis", col = heat.colors(20))

# SPM penalty (differential penalties)
image(as.matrix(penalty_spm), main = "SPM+Derivatives Penalty\n(Differential weights)", 
      xlab = "Basis", ylab = "Basis", col = heat.colors(20))

par(mfrow = c(1, 1))

# Show the diagonal values
penalty_comparison <- data.frame(
  Basis_Type = c(rep("FIR", 8), rep("B-spline", 6), rep("SPM+Derivatives", 3)),
  Basis_Index = c(1:8, 1:6, 1:3),
  Diagonal_Value = c(diag(penalty_fir), diag(penalty_bspline), diag(penalty_spm)),
  Basis_Name = c(paste0("FIR_", 1:8), paste0("Bspline_", 1:6), 
                 c("Canonical", "Temporal_Deriv", "Dispersion_Deriv"))
)

ggplot(penalty_comparison, aes(x = Basis_Index, y = Diagonal_Value, fill = Basis_Type)) +
  geom_col() +
  facet_wrap(~Basis_Type, scales = "free_x") +
  scale_fill_viridis_d() +
  labs(title = "Actual Penalty Matrix Diagonal Values",
       subtitle = "Currently only implements identity (ridge) penalty for FIR/B-spline",
       x = "Basis Function Index",
       y = "Penalty Weight (Diagonal Value)") +
  theme_minimal() +
  theme(legend.position = "none")

# Demonstrate conceptually what different penalty orders SHOULD do
# Create example coefficient vector
example_coefs <- c(0.1, 0.3, 0.8, 1.0, 0.9, 0.5, 0.1, -0.1)

# Manually create different penalty matrices to show the concept
n <- length(example_coefs)

# Order 0: Identity (ridge) - penalizes magnitude
D0 <- diag(n)

# Order 1: First differences - penalizes changes
D1 <- matrix(0, n-1, n)
for(i in 1:(n-1)) {
  D1[i, i] <- -1
  D1[i, i+1] <- 1
}
P1 <- t(D1) %*% D1

# Order 2: Second differences - penalizes curvature
D2 <- matrix(0, n-2, n)
for(i in 1:(n-2)) {
  D2[i, i] <- 1
  D2[i, i+1] <- -2
  D2[i, i+2] <- 1
}
P2 <- t(D2) %*% D2

# Calculate penalty values
penalty_vals <- data.frame(
  Penalty_Type = c("Order 0 (Ridge)", "Order 1 (Difference)", "Order 2 (Smoothness)"),
  Value = c(
    t(example_coefs) %*% D0 %*% example_coefs,
    t(example_coefs) %*% P1 %*% example_coefs,
    t(example_coefs) %*% P2 %*% example_coefs
  )
)

ggplot(penalty_vals, aes(x = Penalty_Type, y = Value, fill = Penalty_Type)) +
  geom_col() +
  scale_fill_viridis_d() +
  labs(title = "Conceptual Demonstration: How Different Penalty Orders Should Work",
       subtitle = paste("For coefficient vector:", paste(round(example_coefs, 2), collapse=", ")),
       x = "Penalty Type",
       y = "Penalty Value (β'Rβ)") +
  theme_minimal() +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1))
```

### Penalty Structure for Different Basis Types

Different HRF basis types have specialized penalty structures:

```{r penalty_structure}
# Compare penalty structures
basis_types <- list(
  "FIR/Tent" = gen_hrf(hrf_bspline, N = 8, degree = 1, span = 16),
  "B-spline" = gen_hrf(hrf_bspline, N = 8, degree = 3, span = 16),
  "SPM+Derivatives" = HRF_SPMG3
)

# Extract key penalty properties and examine structure
penalty_info <- data.frame()
for (name in names(basis_types)) {
  pen <- penalty_matrix(basis_types[[name]], order = 2)
  pen_mat <- as.matrix(pen)
  
  # For SPM+derivatives, we expect different diagonal values
  # For FIR/B-spline, the penalty encodes smoothness constraints
  if (name == "SPM+Derivatives") {
    # SPM basis: canonical, temporal deriv, dispersion deriv
    pen_vals <- diag(pen_mat)
    # Show actual penalty values
    info <- data.frame(
      Basis_Type = name,
      Basis_Index = 1:length(pen_vals),
      Basis_Label = c("Canonical", "Temporal Deriv", "Dispersion Deriv"),
      Penalty_Weight = pen_vals,
      Log_Penalty = log10(pen_vals + 1e-10)  # Log scale to see differences
    )
  } else {
    # For FIR/B-spline, show row sums (total penalty per basis function)
    row_penalties <- rowSums(abs(pen_mat))
    info <- data.frame(
      Basis_Type = name,
      Basis_Index = 1:length(row_penalties),
      Basis_Label = paste0("Basis ", 1:length(row_penalties)),
      Penalty_Weight = row_penalties,
      Log_Penalty = log10(row_penalties + 1e-10)
    )
  }
  penalty_info <- rbind(penalty_info, info)
}

# First, show the raw penalty values
ggplot(penalty_info, aes(x = Basis_Index, y = Penalty_Weight, fill = Basis_Type)) +
  geom_col() +
  facet_wrap(~Basis_Type, scales = "free") +
  scale_fill_viridis_d() +
  labs(title = "Penalty Structure Across Basis Types",
       subtitle = "Raw penalty values (diagonal for SPM, row sums for others)",
       x = "Basis Function Index",
       y = "Penalty Weight") +
  theme_minimal() +
  theme(legend.position = "none")

# For SPM specifically, show the differential penalties
spm_info <- penalty_info[penalty_info$Basis_Type == "SPM+Derivatives",]
if (nrow(spm_info) > 0) {
  ggplot(spm_info, aes(x = Basis_Label, y = Penalty_Weight, fill = Basis_Label)) +
    geom_col() +
    scale_fill_manual(values = c("Canonical" = "#440154", 
                                "Temporal Deriv" = "#31688e",
                                "Dispersion Deriv" = "#35b779")) +
    labs(title = "SPM Basis: Differential Penalty Weights",
         subtitle = "Derivative terms receive higher penalties to encourage smoothness",
         x = "Basis Function",
         y = "Penalty Weight") +
    theme_minimal() +
    theme(legend.position = "none")
}
```

## Reconstruction Matrices: From Coefficients to HRF Shapes

The reconstruction process converts a set of basis coefficients into a continuous HRF shape. Understanding this transformation is key to interpreting estimated HRFs from fMRI analyses.

### How Reconstruction Works

```{r reconstruction_demo}
# Use a small basis for clear visualization
basis_set <- gen_hrf(hrf_bspline, N = 5, degree = 3, span = 30)
eval_times <- seq(0, 30, by = 0.1)

# The reconstruction matrix: each column is a basis function evaluated at time points
recon_matrix <- basis_set(eval_times)
print(paste("Reconstruction matrix dimensions:", nrow(recon_matrix), "time points x", 
            ncol(recon_matrix), "basis functions"))

# Let's visualize the basis functions themselves first
basis_df <- as.data.frame(recon_matrix)
names(basis_df) <- paste0("B", 1:5)
basis_df$Time <- eval_times

basis_long <- pivot_longer(basis_df, -Time, names_to = "Basis", values_to = "Value")

ggplot(basis_long, aes(x = Time, y = Value, color = Basis)) +
  geom_line(linewidth = 1.2) +
  scale_color_viridis_d(option = "turbo") +
  labs(title = "B-spline Basis Functions",
       subtitle = "Each basis function covers a different time window",
       x = "Time (seconds)",
       y = "Basis Function Value") +
  theme_minimal()

# Now demonstrate reconstruction with different coefficient patterns
coefficient_sets <- list(
  "Early Peak" = c(0.2, 1.0, 0.3, 0.0, 0.0),
  "Canonical" = c(0.0, 0.3, 1.0, 0.4, -0.1),
  "Late Peak" = c(0.0, 0.0, 0.3, 1.0, 0.2),
  "Double Peak" = c(0.0, 0.8, 0.2, 0.9, 0.0)
)

# Reconstruct HRFs for each coefficient set
reconstruction_df <- data.frame()
for (name in names(coefficient_sets)) {
  coefs <- coefficient_sets[[name]]
  hrf_values <- as.vector(recon_matrix %*% coefs)
  
  df <- data.frame(
    Time = eval_times,
    HRF = hrf_values,
    Pattern = name
  )
  reconstruction_df <- rbind(reconstruction_df, df)
}

ggplot(reconstruction_df, aes(x = Time, y = HRF, color = Pattern)) +
  geom_line(linewidth = 1.5) +
  scale_color_manual(values = c("Early Peak" = "#E69F00", 
                               "Canonical" = "#009E73",
                               "Late Peak" = "#0072B2",
                               "Double Peak" = "#D55E00")) +
  labs(title = "Different HRF Shapes from Same Basis Set",
       subtitle = "Varying coefficients produces diverse HRF patterns",
       x = "Time (seconds)",
       y = "HRF Response") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

### Interactive Visualization: Building an HRF Step by Step

```{r reconstruction_interactive}
# Let's build up a canonical HRF step by step
canonical_coefs <- c(0.0, 0.3, 1.0, 0.4, -0.1)

# Create data for cumulative reconstruction
cumulative_df <- data.frame()
for (i in 1:5) {
  # Zero out coefficients after position i
  temp_coefs <- canonical_coefs
  if (i < 5) temp_coefs[(i+1):5] <- 0
  
  # Calculate cumulative HRF
  cumulative_hrf <- as.vector(recon_matrix %*% temp_coefs)
  
  # Store individual contribution
  individual_coefs <- rep(0, 5)
  individual_coefs[i] <- canonical_coefs[i]
  individual_contribution <- as.vector(recon_matrix %*% individual_coefs)
  
  df <- data.frame(
    Time = rep(eval_times, 2),
    Value = c(cumulative_hrf, individual_contribution),
    Type = rep(c("Cumulative", "Individual"), each = length(eval_times)),
    Step = i,
    Basis = paste0("Adding B", i, " (coef=", round(canonical_coefs[i], 2), ")")
  )
  cumulative_df <- rbind(cumulative_df, df)
}

# Create faceted plot showing the build-up
ggplot(cumulative_df, aes(x = Time, y = Value, color = Type)) +
  geom_line(linewidth = 1.2) +
  facet_wrap(~Basis, ncol = 5) +
  scale_color_manual(values = c("Cumulative" = "black", "Individual" = "red")) +
  labs(title = "Building an HRF: Sequential Addition of Weighted Basis Functions",
       subtitle = "Red: individual contribution, Black: cumulative sum",
       x = "Time (seconds)",
       y = "Value") +
  theme_minimal() +
  theme(legend.position = "bottom",
        strip.text = element_text(size = 9))

# Show coefficient importance
coef_importance <- data.frame(
  Basis = paste0("B", 1:5),
  Coefficient = canonical_coefs,
  `Absolute Value` = abs(canonical_coefs)
)

ggplot(coef_importance, aes(x = Basis, y = Coefficient, fill = Coefficient > 0)) +
  geom_col() +
  geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
  scale_fill_manual(values = c("FALSE" = "#D55E00", "TRUE" = "#009E73"),
                    labels = c("Negative", "Positive")) +
  labs(title = "Coefficient Values for Canonical HRF",
       subtitle = "B3 dominates the shape, B5 provides the undershoot",
       x = "Basis Function",
       y = "Coefficient Value",
       fill = "Sign") +
  theme_minimal()
```

## Regressor Sets: Multi-Condition Experimental Designs

The `regressor_set()` function simplifies creating regressors for multi-condition experiments where each condition shares the same HRF but has different event timings.

```{r regressor_set_demo}
# Simulate a 3-condition experiment
set.seed(123)
n_events_per_condition <- 8
total_duration <- 240  # 4 minutes

# Generate random onsets for each condition
condition_A_onsets <- sort(runif(n_events_per_condition, 0, total_duration))
condition_B_onsets <- sort(runif(n_events_per_condition, 0, total_duration))
condition_C_onsets <- sort(runif(n_events_per_condition, 0, total_duration))

# Combine all onsets and create factor
all_onsets <- c(condition_A_onsets, condition_B_onsets, condition_C_onsets)
conditions <- factor(rep(c("TaskA", "TaskB", "TaskC"), each = n_events_per_condition))

# Create regressor set
reg_set <- regressor_set(onsets = all_onsets, fac = conditions, hrf = HRF_SPMG1)
print(reg_set)

# Evaluate at scan times (TR = 2s)
TR <- 2
scan_times <- seq(0, total_duration, by = TR)
design_matrix <- evaluate(reg_set, scan_times)

print(dim(design_matrix)) # Time points x 3 conditions

# Visualize the design matrix
design_df <- as.data.frame(design_matrix)
names(design_df) <- c("TaskA", "TaskB", "TaskC")
design_df$Time <- scan_times

design_long <- pivot_longer(design_df, -Time, names_to = "Condition", values_to = "Response")

ggplot(design_long, aes(x = Time, y = Response, color = Condition)) +
  geom_line(linewidth = 1) +
  scale_color_viridis_d() +
  labs(title = "Multi-Condition fMRI Design Matrix",
       subtitle = "Three experimental conditions with shared HRF",
       x = "Time (seconds)",
       y = "Predicted BOLD Response",
       color = "Condition") +
  theme_minimal()

# Add event markers
onset_df <- data.frame(
  Time = all_onsets,
  Condition = conditions,
  Marker = 1
)

ggplot(design_long, aes(x = Time, y = Response, color = Condition)) +
  geom_line(linewidth = 1) +
  geom_point(data = onset_df, aes(x = Time, y = -0.1, color = Condition), 
             size = 2, alpha = 0.7) +
  scale_color_viridis_d() +
  labs(title = "Design Matrix with Event Onsets",
       subtitle = "Points show stimulus onset times",
       x = "Time (seconds)",
       y = "Predicted BOLD Response",
       color = "Condition") +
  theme_minimal()
```

## Regressor Design: Complex Block Designs

For more complex experimental designs with multiple blocks or runs, `regressor_design()` provides a higher-level interface that handles block-relative timing and creates design matrices directly.

```{r regressor_design_demo}
# Create a sampling frame for 2 blocks of 120 seconds each
sframe <- sampling_frame(
  blocklens = c(120, 120),  # Two 4-minute blocks (120 scans each at TR = 2s)
  TR = 2                    # 2-second TR
)
print(sframe)

# Generate block-relative event onsets
# Block 1: Faces at 10, 50, 90; Houses at 30, 70 seconds
# Block 2: Faces at 15, 55, 95; Houses at 35, 75 seconds  
block_onsets <- c(10, 30, 50, 70, 90, 15, 35, 55, 75, 95)
block_ids <- c(rep(1, 5), rep(2, 5))
event_conditions <- factor(c("Faces", "Houses", "Faces", "Houses", "Faces", 
                            "Faces", "Houses", "Faces", "Houses", "Faces"))

# Create design matrix using regressor_design
design_mat <- regressor_design(
  onsets = block_onsets,
  fac = event_conditions,
  block = block_ids,
  sframe = sframe,
  hrf = HRF_SPMG1
)

print(dim(design_mat)) # Total time points across both blocks x 2 conditions

# Convert to data frame for plotting
time_points <- samples(sframe)
design_plot_df <- as.data.frame(design_mat)
names(design_plot_df) <- c("Faces", "Houses")
design_plot_df$Time <- time_points
design_plot_df$Block <- rep(1:2, each = 120) # 120 scans per block

design_plot_long <- pivot_longer(design_plot_df, c("Faces", "Houses"), 
                                names_to = "Condition", values_to = "Response")

# Plot with block separation
ggplot(design_plot_long, aes(x = Time, y = Response, color = Condition)) +
  geom_line(linewidth = 1) +
  geom_vline(xintercept = 240, linetype = "dashed", alpha = 0.7) +
  scale_color_viridis_d() +
  labs(title = "Multi-Block Experimental Design",
       subtitle = "Two blocks with different event schedules (dashed line = block boundary)",
       x = "Time (seconds)",
       y = "Predicted BOLD Response",
       color = "Condition") +
  theme_minimal()

# Show global vs block-relative timing
timing_df <- data.frame(
  Block = block_ids,
  Block_Relative_Onset = block_onsets,
  Global_Onset = global_onsets(sframe, block_onsets, block_ids),
  Condition = event_conditions
)

print(timing_df)
```

### Advanced: Parametric Modulation in Block Designs

`regressor_design()` also supports parametric modulation and varying event durations within block designs:

```{r parametric_block_design}
# Add parametric modulation (e.g., task difficulty)
difficulty_ratings <- c(1, 3, 2, 4, 5, 2, 4, 1, 5, 3) # 1=easy, 5=hard
event_durations <- c(2, 2, 3, 3, 2, 3, 3, 2, 2, 3) # Varying durations

# Create design with modulation
param_design <- regressor_design(
  onsets = block_onsets,
  fac = event_conditions,
  block = block_ids,
  sframe = sframe,
  hrf = HRF_SPMG1,
  amplitude = scale(difficulty_ratings, center = TRUE, scale = FALSE)[,1], # Center the modulator
  duration = event_durations
)

print(dim(param_design)) # Should still be time points x 2 conditions

# Plot the parametric design
param_plot_df <- as.data.frame(param_design)
names(param_plot_df) <- c("Faces", "Houses")
param_plot_df$Time <- time_points

param_plot_long <- pivot_longer(param_plot_df, c("Faces", "Houses"),
                               names_to = "Condition", values_to = "Response")

ggplot(param_plot_long, aes(x = Time, y = Response, color = Condition)) +
  geom_line(linewidth = 1) +
  geom_vline(xintercept = 240, linetype = "dashed", alpha = 0.7) +
  scale_color_viridis_d() +
  labs(title = "Parametric Modulation in Block Design",
       subtitle = "Event amplitudes modulated by difficulty ratings",
       x = "Time (seconds)",
       y = "Modulated BOLD Response",
       color = "Condition") +
  theme_minimal()
```

## Putting It All Together: A Complete Analysis Pipeline

Here's how these advanced functions work together in a typical analysis:

```{r complete_pipeline}
# Step 1: Create an HRF library for model comparison
hrf_variants <- expand.grid(
  shape = c(5, 6, 7),
  rate = c(0.9, 1.0, 1.1)
)

hrf_lib <- hrf_library(make_gamma_hrf, hrf_variants)

# Step 2: Create a complex experimental design
sframe_complex <- sampling_frame(blocklens = c(180, 180, 180), TR = 2)

# Events across 3 blocks with 2 conditions
events_per_block <- 6
onsets_complex <- rep(seq(20, 160, length.out = events_per_block), 3)
blocks_complex <- rep(1:3, each = events_per_block)
conditions_complex <- factor(rep(c("A", "B"), length.out = length(onsets_complex)))

# Step 3: Build design matrix
design_complex <- regressor_design(
  onsets = onsets_complex,
  fac = conditions_complex,
  block = blocks_complex,
  sframe = sframe_complex,
  hrf = hrf_lib  # Using our HRF library!
)

print(dim(design_complex)) # Time points x (2 conditions × 9 HRF variants) = 18 columns

# Step 4: Create penalty matrix for regularization
penalty_hrf_lib <- penalty_matrix(hrf_lib, order = 2)
print(dim(penalty_hrf_lib)) # 18 x 18 penalty matrix

# Visualize the resulting design matrix (first few HRF variants)
complex_df <- as.data.frame(design_complex[, 1:6]) # First 6 columns
names(complex_df) <- paste0("Cond", rep(c("A", "B"), 3), "_HRF", rep(1:3, each = 2))
complex_df$Time <- samples(sframe_complex)

complex_long <- pivot_longer(complex_df, -Time, names_to = "Regressor", values_to = "Response")

ggplot(complex_long, aes(x = Time, y = Response, color = Regressor)) +
  geom_line(linewidth = 0.8, alpha = 0.8) +
  geom_vline(xintercept = c(360, 720), linetype = "dashed", alpha = 0.5) +
  scale_color_viridis_d() +
  labs(title = "Complex Design: Multiple Conditions × HRF Library",
       subtitle = "2 conditions × 3 HRF variants shown (6 of 18 total regressors)",
       x = "Time (seconds)",
       y = "Predicted Response") +
  theme_minimal() +
  theme(legend.position = "bottom") +
  guides(color = guide_legend(nrow = 2))
```

## Summary

The advanced functions in `fmrihrf` provide a powerful toolkit for sophisticated HRF modeling:

- **`hrf_library()`** enables systematic exploration of HRF parameter space
- **`penalty_matrix()`** provides principled regularization for stable estimation
- **`reconstruction_matrix()`** allows interpretation of estimated coefficients
- **`regressor_set()`** simplifies multi-condition experimental designs
- **`regressor_design()`** handles complex block-based experiments with parametric modulation

Together, these functions support advanced fMRI analysis workflows that go beyond simple canonical HRF assumptions, enabling more flexible and data-driven approaches to hemodynamic response modeling.