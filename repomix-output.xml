This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: R/**/*.R, R/**/*.r, *.Rmd, *.rmd, DESCRIPTION, tests/**/*.R, tests/**/*.r
- Files matching patterns in .gitignore are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
R/
  all_generic.R
  evaluate-helpers.R
  fmrihrf-package.R
  hrf_decorators.R
  hrf_from_coefficients.R
  hrf-formula.R
  hrf-functions.R
  hrf.R
  neural_input_methods.R
  penalty_matrix_methods.R
  RcppExports.R
  reg-constructor.R
  reg-methods.R
  regressor-design.R
  regressor-set.R
  sampling_frame.R
  utils-internal.R
tests/
  testthat/
    test_acquisition_onsets.R
    test_afni_hrf_aliases.R
    test_fft_and_toeplitz.R
    test_hrf_from_coefficients.R
    test_hrf_library.R
    test_hrf_lwu_extra.R
    test_hrf.R
    test_penalty_matrix.R
    test_reg_constructor.R
    test_regressor_design.R
    test_regressor_set.R
    test_regressor.R
    test_sampling_frame.R
    test_utils.R
DESCRIPTION
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="R/hrf_from_coefficients.R">
#' @export
#' @rdname hrf_from_coefficients
hrf_from_coefficients.HRF <- function(hrf, h, name = NULL, ...) {
  nb <- nbasis(hrf)
  if (length(h) != nb) {
    stop("length(h) must equal nbasis(hrf)")
  }
  weighted_fun <- function(t) {
    vals <- hrf(t)
    if (is.matrix(vals)) {
      drop(vals %*% as.numeric(h))
    } else {
      vals * h[1L]
    }
  }
  if (is.null(name)) {
    name <- paste0(attr(hrf, "name"), "_from_coef")
  }
  as_hrf(
    f      = weighted_fun,
    name   = name,
    nbasis = 1L,
    span   = attr(hrf, "span"),
    params = c(attr(hrf, "params"), list(coefficients = h))
  )
}
</file>

<file path="R/RcppExports.R">
# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

neural_input_rcpp <- function(x, from, to, resolution) {
    .Call(`_fmrihrf_neural_input_rcpp`, x, from, to, resolution)
}

evaluate_regressor_convolution <- function(grid, onsets, durations, amplitudes, hrf_values, hrf_span, start, end, precision) {
    .Call(`_fmrihrf_evaluate_regressor_convolution`, grid, onsets, durations, amplitudes, hrf_values, hrf_span, start, end, precision)
}

evaluate_regressor_fast <- function(grid, onsets, durations, amplitudes, hrfFine, dt, span) {
    .Call(`_fmrihrf_evaluate_regressor_fast`, grid, onsets, durations, amplitudes, hrfFine, dt, span)
}

evaluate_regressor_cpp <- function(grid, onsets, durations, amplitudes, hrf_matrix, hrf_span, precision, method = "fft") {
    .Call(`_fmrihrf_evaluate_regressor_cpp`, grid, onsets, durations, amplitudes, hrf_matrix, hrf_span, precision, method)
}
</file>

<file path="tests/testthat/test_afni_hrf_aliases.R">
context("afni hrf aliases")

test_that("afni_hrf accepts sin/gam aliases", {
  # afni_hrf needs a variable name
  spec_sin <- afni_hrf(cond, basis = "sin")
  spec_gam <- afni_hrf(cond, basis = "gam")

  # AFNI_HRF objects store the name as the base object value itself
  expect_equal(as.vector(spec_sin$hrf), "SIN")
  expect_equal(as.vector(spec_gam$hrf), "GAM")
})
</file>

<file path="R/hrf-functions.R">
#' @importFrom splines bs
#' @importFrom stats dgamma dnorm quantile
NULL

#' HRF (hemodynamic response function) as a linear function of time
#'
#' The `hrf_time` function computes the value of an HRF, which is a simple linear function of time `t`, when `t` is greater than 0 and less than `maxt`.
#'
#' @param t A numeric value representing time in seconds.
#' @param maxt A numeric value representing the maximum time point in the domain. Default value is 22.
#' @return A numeric value representing the value of the HRF at the given time `t`.
#' @family hrf_functions
#' @export
#' @examples
#' # Compute the HRF value for t = 5 seconds with the default maximum time
#' hrf_val <- hrf_time(5)
#'
#' # Compute the HRF value for t = 5 seconds with a custom maximum time of 30 seconds
#' hrf_val_custom_maxt <- hrf_time(5, maxt = 30)
hrf_time <- function(t, maxt=22) {
  ifelse(t > 0 & t < maxt, t, 0)
}

# hrf_ident
# 
# @param t time in seconds
# @export
hrf_ident <- function(t) {
  ifelse( t == 0, 1, 0)
}

#' B-spline HRF (hemodynamic response function)
#'
#' The `hrf_bspline` function computes the B-spline representation of an HRF (hemodynamic response function) at given time points `t`.
#'
#' @param t A vector of time points.
#' @param span A numeric value representing the temporal window over which the basis set spans. Default value is 20.
#' @param N An integer representing the number of basis functions. Default value is 5.
#' @param degree An integer representing the degree of the spline. Default value is 3.
#' @return A matrix representing the B-spline basis for the HRF at the given time points `t`.
#' @family hrf_functions
#' @examples
#' # Compute the B-spline HRF representation for time points from 0 to 20 with 0.5 increments
#' hrfb <- hrf_bspline(seq(0, 20, by = .5), N = 4, degree = 2)
#' @export
#' @importFrom splines bs
#' @param ... Additional arguments passed to `splines::bs`.
hrf_bspline <- function(t, span=24, N=5, degree=3, ...) {
	
	ord <- 1 + degree
	# Check if requested N is sufficient for the degree
	if (N < ord) {
	    warning(paste0("Requested N=", N, " basis functions is less than degree+1=", ord, ". ",
	                   "Using minimum required of ", ord, " basis functions."))
	    # We don't change N here, let splines::bs handle the df inconsistency if needed,
	    # but the warning informs the user.
	}
	
	nIknots <- N - ord + 1
	if (nIknots < 0) {
		nIknots <- 0
		#warning("'df' was too small; have used  ", ord - (1 - intercept))
	}
	
	knots <- if (nIknots > 0) {
				knots <- seq.int(from = 0, to = 1, length.out = nIknots + 2)[-c(1, nIknots + 2)]
				stats::quantile(seq(0,span), knots)
			} else {
				0
			}
	
	if (any(t < 0)) {
		t[t < 0] <- 0
	}
	
	if(any(t > span)) {
		t[t > span] <- 0
	}
	
	splines::bs(t, df=N, knots=knots, degree=degree, Boundary.knots=c(0,span),...)
}


#' Gamma HRF (hemodynamic response function)
#'
#' The `hrf_gamma` function computes the gamma density-based HRF (hemodynamic response function) at given time points `t`.
#'
#' @param t A vector of time points.
#' @param shape A numeric value representing the shape parameter for the gamma probability density function. Default value is 6.
#' @param rate A numeric value representing the rate parameter for the gamma probability density function. Default value is 1.
#' @return A numeric vector representing the gamma HRF at the given time points `t`.
#' @family hrf_functions
#' @examples
#' # Compute the gamma HRF representation for time points from 0 to 20 with 0.5 increments
#' hrf_gamma_vals <- hrf_gamma(seq(0, 20, by = .5), shape = 6, rate = 1)
#' @export
hrf_gamma <- function(t, shape=6, rate=1) {
  stats::dgamma(t, shape=shape, rate=rate)
}

#' Gaussian HRF (hemodynamic response function)
#'
#' The `hrf_gaussian` function computes the Gaussian density-based HRF (hemodynamic response function) at given time points `t`.
#'
#' @param t A vector of time points.
#' @param mean A numeric value representing the mean of the Gaussian probability density function. Default value is 6.
#' @param sd A numeric value representing the standard deviation of the Gaussian probability density function. Default value is 2.
#' @return A numeric vector representing the Gaussian HRF at the given time points `t`.
#' @family hrf_functions
#' @examples
#' # Compute the Gaussian HRF representation for time points from 0 to 20 with 0.5 increments
#' hrf_gaussian_vals <- hrf_gaussian(seq(0, 20, by = .5), mean = 6, sd = 2)
#' @export
hrf_gaussian <- function(t, mean=6, sd=2) {
	stats::dnorm(t, mean=mean, sd=sd)
}



#' Mexican Hat HRF (hemodynamic response function)
#'
#' The `hrf_mexhat` function computes the Mexican hat wavelet-based HRF (hemodynamic response function) at given time points `t`.
#'
#' @param t A vector of time points.
#' @param mean A numeric value representing the mean of the Mexican hat wavelet. Default value is 6.
#' @param sd A numeric value representing the standard deviation of the Mexican hat wavelet. Default value is 2.
#' @return A numeric vector representing the Mexican hat wavelet-based HRF at the given time points `t`.
#' @family hrf_functions
#' @examples
#' # Compute the Mexican hat HRF representation for time points from 0 to 20 with 0.5 increments
#' hrf_mexhat_vals <- hrf_mexhat(seq(0, 20, by = .5), mean = 6, sd = 2)
#' @export
hrf_mexhat <- function(t, mean = 6, sd = 2) {
  t0 <- t - mean
  a <- (1 - (t0 / sd)^2) * exp(-t0^2 / (2 * sd^2))
  scale <- sqrt(2 / (3 * sd * pi^(1/4)))
  return(scale * a)
}

#' hrf_spmg1
#'
#' A hemodynamic response function based on the SPM canonical double gamma parameterization.
#'
#' This function models the hemodynamic response using the canonical double gamma parameterization
#' in the SPM software. The HRF is defined by a linear combination of two gamma functions with
#' different exponents (P1 and P2) and amplitudes (A1 and A2). It is commonly used in fMRI data
#' analysis to estimate the BOLD (blood-oxygen-level-dependent) signal changes associated with
#' neural activity.
#'
#' @param t A vector of time points.
#' @param P1 The first exponent parameter (default: 5).
#' @param P2 The second exponent parameter (default: 15).
#' @param A1 Amplitude scaling factor for the positive gamma function component; normally fixed at .0833
#' @return A vector of HRF values at the given time points.
#' @family hrf_functions
#' @export
#' @examples
#' # Generate a time vector
#' time_points <- seq(0, 30, by=0.1)
#' # Compute the HRF values using the SPM canonical double gamma parameterization
#' hrf_values <- hrf_spmg1(time_points)
#' # Plot the HRF values
#' plot(time_points, hrf_values, type='l', main='SPM Canonical Double Gamma HRF')
hrf_spmg1 <- function(t, P1=5, P2=15,A1=.0833) {
 	ifelse(t < 0, 0, exp(-t)*(A1*t^P1 - 1.274527e-13*t^P2))
	
}


# Fast analytic first derivative for hrf_spmg1
#' @keywords internal
#' @noRd
hrf_spmg1_deriv <- function(t, P1 = 5, P2 = 15, A1 = .0833) {
  C <- 1.274527e-13
  ret <- numeric(length(t))
  pos <- t >= 0
  if (any(pos)) {
    t_pos <- t[pos]
    ret[pos] <- exp(-t_pos) * (A1 * t_pos^(P1 - 1) * (P1 - t_pos) -
                                 C   * t_pos^(P2 - 1) * (P2 - t_pos))
  }
  ret
}

# Fast analytic second derivative for hrf_spmg1
#' @keywords internal
#' @noRd
hrf_spmg1_second_deriv <- function(t, P1 = 5, P2 = 15, A1 = .0833) {
  C <- 1.274527e-13
  ret <- numeric(length(t))
  pos <- t >= 0
  if (any(pos)) {
    t_pos <- t[pos]
    # Let D1 = A1 * t^(P1-1) * (P1 - t) and D2 = C * t^(P2-1) * (P2 - t)
    D1 <- A1 * t_pos^(P1 - 1) * (P1 - t_pos)
    D2 <- C   * t_pos^(P2 - 1) * (P2 - t_pos)
    # Their derivatives:
    D1_prime <- A1 * ((P1 - 1) * t_pos^(P1 - 2) * (P1 - t_pos) - t_pos^(P1 - 1))
    D2_prime <- C   * ((P2 - 1) * t_pos^(P2 - 2) * (P2 - t_pos) - t_pos^(P2 - 1))
    ret[pos] <- exp(-t_pos) * (D1_prime - D2_prime - (D1 - D2))
  }
  ret
}

#' hrf_sine
#'
#' A hemodynamic response function using the Sine Basis Set.
#'
#' @param t A vector of times.
#' @param span The temporal window over which the basis sets span (default: 24).
#' @param N The number of basis functions (default: 5).
#' @return A matrix of sine basis functions.
#' @family hrf_functions
#' @export
#' @examples
#' hrf_sine_basis <- hrf_sine(seq(0, 20, by = 0.5), N = 4)
hrf_sine <- function(t, span = 24, N = 5) {
  sine_basis <- sapply(1:N, function(n) {
    sin(2 * pi * n * t / span)
  })
  return(sine_basis)
}

#' hrf_inv_logit
#'
#' A hemodynamic response function using the difference of two Inverse Logit functions.
#'
#' @param t A vector of times.
#' @param mu1 The time-to-peak for the rising phase (mean of the first logistic function).
#' @param s1 The width (slope) of the first logistic function.
#' @param mu2 The time-to-peak for the falling phase (mean of the second logistic function).
#' @param s2 The width (slope) of the second logistic function.
#' @param lag The time delay (default: 0).
#' @return A vector of the difference of two Inverse Logit HRF values.
#' @family hrf_functions
#' @export
#' @examples
#' hrf_inv_logit_basis <- hrf_inv_logit(seq(0, 20, by = 0.5), mu1 = 6, s1 = 1, mu2 = 16, s2 = 1)
hrf_inv_logit <- function(t, mu1 = 6, s1 = 1, mu2 = 16, s2 = 1, lag = 0) {
  inv_logit1 <- 1 / (1 + exp(-(t - lag - mu1) / s1))
  inv_logit2 <- 1 / (1 + exp(-(t - lag - mu2) / s2))
  return(inv_logit1 - inv_logit2)
}


#' Hemodynamic Response Function with Half-Cosine Basis
#'
#' This function models a hemodynamic response function (HRF) using four half-period cosine basis functions.
#' The HRF consists of an initial dip, a rise to peak, a fall and undershoot, and a recovery to the baseline.
#'
#' @param t A vector of time values.
#' @param h1 Duration of the initial dip in seconds.
#' @param h2 Duration of the rise to peak in seconds.
#' @param h3 Duration of the fall and undershoot in seconds.
#' @param h4 Duration of the recovery to baseline in seconds.
#' @param f1 Height of the starting point.
#' @param f2 Height of the end point.
#' @return A vector of HRF values corresponding to the input time values.
#' @references Woolrich, M. W., Behrens, T. E., & Smith, S. M. (2004). Constrained linear basis sets for HRF modelling using Variational Bayes. NeuroImage, 21(4), 1748-1761.
#'
#' Half-cosine HRF
#'
#' Creates a hemodynamic response function using half-cosine segments.
#' The function consists of four phases controlled by h1-h4 parameters,
#' with transitions between baseline (f1) and peak (1) and final (f2) levels.
#'
#' @param t Time points at which to evaluate the HRF
#' @param h1 Duration of initial fall from f1 to 0 (default: 1)
#' @param h2 Duration of rise from 0 to 1 (default: 5)
#' @param h3 Duration of fall from 1 to 0 (default: 7)
#' @param h4 Duration of final rise from 0 to f2 (default: 7)
#' @param f1 Initial baseline level (default: 0)
#' @param f2 Final baseline level (default: 0)
#' @return Numeric vector of HRF values at time points t
#' @examples
#' # Standard half-cosine HRF
#' t <- seq(0, 30, by = 0.1)
#' hrf <- hrf_half_cosine(t)
#' plot(t, hrf, type = "l", main = "Half-cosine HRF")
#' 
#' # Modified shape with undershoot
#' hrf_under <- hrf_half_cosine(t, h1 = 1, h2 = 4, h3 = 6, h4 = 8, f2 = -0.2)
#' lines(t, hrf_under, col = "red")
#' @export
hrf_half_cosine <- function(t, h1=1, h2=5, h3=7,h4=7, f1=0, f2=0) {
  rising_half_cosine <- function(t, f1, t0, w) {
    return(f1/2 * (1 - cos(pi * (t - t0) / w)))
  }
  
  falling_half_cosine <- function(t, f1, t0, w) {
    return(f1/2 * (1 + cos(pi * (t - t0) / w)))
  }
  
  ret = dplyr::case_when(
    t < 0 ~ 0,
    t <= h1 ~ falling_half_cosine(t, f1, 0, h1),
    (t > h1) & t <= (h1+h2) ~ rising_half_cosine(t, 1, h1, h2),
    (t > (h1+h2)) & t <= (h1+h2+h3) ~ falling_half_cosine(t,1,(h1+h2), h3),
    (t > (h1+h2+h3)) & t <= (h1+h2+h3+h4) ~ rising_half_cosine(t,f2,(h1+h2+h3), h4),
    (t > h1+h2+h3+h4) ~ f2,
  )
  return(ret)
}

#' Fourier basis for HRF modeling
#'
#' Generates a set of Fourier basis functions (sine and cosine pairs) over a given span.
#'
#' @param t A vector of time points.
#' @param span The temporal window over which the basis functions span (default: 24).
#' @param nbasis The number of basis functions (default: 5). Should be even for full sine-cosine pairs.
#' @return A matrix of Fourier basis functions with nbasis columns.
#' @export
hrf_fourier <- function(t, span = 24, nbasis = 5) {
  freqs <- ceiling(seq_len(nbasis) / 2)
  basis <- sapply(seq_len(nbasis), function(k) {
    n <- freqs[k]
    if (k %% 2 == 1) {
      sin(2 * pi * n * t / span)
    } else {
      cos(2 * pi * n * t / span)
    }
  })
  return(basis)
}



#' HRF Toeplitz Matrix
#' 
#' @description
#' Create a Toeplitz matrix for hemodynamic response function (HRF) convolution.
#' 
#' @param hrf The hemodynamic response function.
#' @param time A numeric vector representing the time points.
#' @param len The length of the output Toeplitz matrix.
#' @param sparse Logical, if TRUE, the output Toeplitz matrix is returned as a sparse matrix (default: FALSE).
#' 
#' @return A Toeplitz matrix for HRF convolution.
#' @examples
#' # Create HRF and time points
#' hrf_fun <- function(t) hrf_spmg1(t)
#' times <- seq(0, 30, by = 1)
#' 
#' # Create Toeplitz matrix
#' H <- hrf_toeplitz(hrf_fun, times, len = 50)
#' 
#' # Create sparse version
#' H_sparse <- hrf_toeplitz(hrf_fun, times, len = 50, sparse = TRUE)
#' @export
hrf_toeplitz <- function(hrf, time, len, sparse=FALSE) {
  hreg <- hrf(time)
  padding <- len - length(hreg)
  H <- pracma::Toeplitz(c(hreg, rep(0, padding)), c(hreg[1], rep(0, len-1)))
  H <- Matrix::Matrix(H, sparse=sparse)
  H
}


#' Generate Daguerre spherical basis functions
#' 
#' @description
#' Creates a set of Daguerre spherical basis functions. These are orthogonal 
#' polynomials on [0,∞) with respect to the weight function w(x) = x^2 * exp(-x).
#' They are particularly useful for modeling hemodynamic responses as they naturally
#' decay to zero and can capture various response shapes.
#'
#' @param t Time points at which to evaluate the basis functions
#' @param n_basis Number of basis functions to generate (default: 3)
#' @param scale Scale parameter for the time axis (default: 1)
#' @return A matrix with columns containing the basis functions
#' @keywords internal
#' @noRd
daguerre_basis <- function(t, n_basis = 3, scale = 1) {
  # Scale time
  x <- t/scale
  
  # Initialize basis matrix
  basis <- matrix(0, length(x), n_basis)
  
  # First basis function (n=0)
  basis[,1] <- exp(-x/2)
  
  if(n_basis > 1) {
    # Second basis function (n=1)
    basis[,2] <- (1 - x) * exp(-x/2)
  }
  
  if(n_basis > 2) {
    # Higher order basis functions using recurrence relation
    for(n in 3:n_basis) {
      k <- n - 1
      basis[,n] <- ((2*k - 1 - x) * basis[,n-1] - (k - 1) * basis[,n-2]) / k
    }
  }
  
  # Normalize basis functions
  for(i in 1:n_basis) {
    # Avoid division by zero if a basis function is all zero
    max_abs_val <- max(abs(basis[,i]))
    if (max_abs_val > 1e-10) {
      basis[,i] <- basis[,i] / max_abs_val
    }
  }
  
  basis
}

#' Lag-Width-Undershoot (LWU) HRF
#'
#' Computes the Lag-Width-Undershoot (LWU) hemodynamic response function.
#' This model uses two Gaussian components to model the main response and an optional undershoot.
#' The formula is:
#' \\deqn{h(t; \\tau, \\sigma, \\rho) = e^{-\\frac{(t-\\tau)^2}{2\\sigma^{2}}} - \\rho e^{-\\frac{(t-\\tau-2\\sigma)^2}{2(1.6\\sigma)^{2}}}}
#'
#' @param t A numeric vector of time points (in seconds).
#' @param tau Lag of the main Gaussian component (time-to-peak of the positive lobe, in seconds). Default: 6.
#' @param sigma Width (standard deviation) of the main Gaussian component (in seconds). Must be > 0.05. Default: 2.5.
#' @param rho Amplitude of the undershoot Gaussian component, relative to the main component. Must be between 0 and 1.5. Default: 0.35.
#' @param normalize Character string specifying normalization type:
#'   \\itemize{
#'     \\item{\\code{"none"}: No normalization is applied (default).}
#'     \\item{\\code{"height"}: The HRF is scaled so that its maximum absolute value is 1.}
#'   }
#' @return A numeric vector representing the LWU HRF values at the given time points `t`.
#' @family hrf_functions
#' @export
#' @examples
#' t_points <- seq(0, 30, by = 0.1)
#'
#' # Default LWU HRF
#' lwu_default <- hrf_lwu(t_points)
#' plot(t_points, lwu_default, type = "l", main = "LWU HRF (Default Params)", ylab = "Amplitude")
#'
#' # LWU HRF with no undershoot
#' lwu_no_undershoot <- hrf_lwu(t_points, rho = 0)
#' lines(t_points, lwu_no_undershoot, col = "blue")
#'
#' # LWU HRF with a wider main peak and larger undershoot
#' lwu_custom <- hrf_lwu(t_points, tau = 7, sigma = 1.5, rho = 0.5)
#' lines(t_points, lwu_custom, col = "red")
#' legend("topright", c("Default", "No Undershoot (rho=0)", "Custom (tau=7, sigma=1.5, rho=0.5)"),
#'        col = c("black", "blue", "red"), lty = 1, cex = 0.8)
#'
#' # Height-normalized HRF
#' lwu_normalized <- hrf_lwu(t_points, tau = 6, sigma = 1, rho = 0.35, normalize = "height")
#' plot(t_points, lwu_normalized, type = "l", main = "Height-Normalized LWU HRF", ylab = "Amplitude")
#' abline(h = c(-1, 1), lty = 2, col = "grey") # Max absolute value should be 1
hrf_lwu <- function(t, tau = 6, sigma = 2.5, rho = 0.35, normalize = "none") {
  assertthat::assert_that(is.numeric(t), msg = "`t` must be numeric.")
  assertthat::assert_that(is.numeric(tau) && length(tau) == 1, msg = "`tau` must be a single numeric value.")
  assertthat::assert_that(is.numeric(sigma) && length(sigma) == 1, msg = "`sigma` must be a single numeric value.")
  assertthat::assert_that(sigma > 0.05, msg = "`sigma` must be > 0.05.")
  assertthat::assert_that(is.numeric(rho) && length(rho) == 1, msg = "`rho` must be a single numeric value.")
  assertthat::assert_that(rho >= 0 && rho <= 1.5, msg = "`rho` must be between 0 and 1.5.")
  assertthat::assert_that(normalize %in% c("none", "height", "area"),
                        msg = "`normalize` must be one of 'none', 'height', or 'area'.")

  if (normalize == "area") {
    warning("`normalize = \"area\"` is not yet fully implemented for hrf_lwu and will behave like `normalize = \"none\"`. Area normalization typically requires numerical integration and careful definition of the integration window for HRFs.", call. = FALSE)
    normalize <- "none"
  }

  # Main positive Gaussian component
  term1_exponent <- -((t - tau)^2) / (2 * sigma^2)
  term1 <- exp(term1_exponent)

  # Undershoot Gaussian component
  # tau_u = tau + 2*sigma (peak of undershoot relative to stimulus onset)
  # sigma_u = 1.6*sigma (width of undershoot)
  term2_exponent <- -((t - (tau + 2 * sigma))^2) / (2 * (1.6 * sigma)^2)
  term2 <- rho * exp(term2_exponent)

  response <- term1 - term2

  if (normalize == "height") {
    max_abs_val <- max(abs(response), na.rm = TRUE)
    if (max_abs_val > 1e-10) { # Avoid division by zero or tiny numbers
      response <- response / max_abs_val
    }
  }

  return(response)
}

#' LWU HRF Basis for Taylor Expansion
#'
#' Constructs the basis set for the Lag-Width-Undershoot (LWU) HRF model,
#' intended for Taylor expansion-based fitting. The basis consists of the
#' LWU HRF evaluated at a given expansion point \code{theta0}, and its
#' partial derivatives with respect to its parameters (tau, sigma, rho).
#'
#' @param theta0 A numeric vector of length 3 specifying the expansion point
#'   \code{c(tau0, sigma0, rho0)} for the LWU parameters.
#' @param t A numeric vector of time points (in seconds) at which to evaluate the basis.
#' @param normalize_primary Character string, one of \code{"none"} or \code{"height"}.
#'   If \code{"height"}, the primary HRF column (\code{h0(t)}) is normalized to have a
#'   peak absolute value of 1. For Taylor expansion fitting as described in Fit_LRU.md,
#'   this should typically be \code{"none"} as the scaling is absorbed by the beta coefficient.
#'   Default is \code{"none"}.
#' @return A numeric matrix of dimension \code{length(t) x 4}. Columns are:
#'   \\itemize{
#'     \\item{\\code{h0}: LWU HRF evaluated at \code{theta0}, \\eqn{h(t; \\tau_0, \\sigma_0, \\rho_0)}}
#'     \\item{\\code{d_tau}: Partial derivative \\eqn{\\partial h / \\partial \\tau} evaluated at \code{theta0}}
#'     \\item{\\code{d_sigma}: Partial derivative \\eqn{\\partial h / \\partial \\sigma} evaluated at \code{theta0}}
#'     \\item{\\code{d_rho}: Partial derivative \\eqn{\\partial h / \\partial \\rho} evaluated at \code{theta0}}
#'   }
#' @family hrf_functions
#' @seealso \code{\link{hrf_lwu}}, \code{\link[numDeriv]{grad}}
#' @export
#' @importFrom numDeriv grad
#' @examples
#' t_points <- seq(0, 30, by = 0.5)
#' theta0_default <- c(tau = 6, sigma = 1, rho = 0.35)
#'
#' # Generate the basis set
#' lwu_basis <- hrf_basis_lwu(theta0_default, t_points)
#' dim(lwu_basis) # Should be length(t_points) x 4
#' head(lwu_basis)
#'
#' # Plot the basis functions
#' matplot(t_points, lwu_basis, type = "l", lty = 1,
#'         main = "LWU HRF Basis Functions", ylab = "Value", xlab = "Time (s)")
#' legend("topright", colnames(lwu_basis), col = 1:4, lty = 1, cex = 0.8)
#'
#' # Example with primary HRF normalization (not typical for Taylor fitting step)
#' lwu_basis_norm_h0 <- hrf_basis_lwu(theta0_default, t_points, normalize_primary = "height")
#' plot(t_points, lwu_basis_norm_h0[,1], type="l", main="Normalized h0 in Basis")
#' max(abs(lwu_basis_norm_h0[,1])) # Should be 1
hrf_basis_lwu <- function(theta0, t, normalize_primary = "none") {
  assertthat::assert_that(is.numeric(theta0) && length(theta0) == 3,
                        msg = "`theta0` must be a numeric vector of length 3: c(tau, sigma, rho).")
  names(theta0) <- c("tau", "sigma", "rho") # Ensure names for numDeriv::grad
  assertthat::assert_that(is.numeric(t), msg = "`t` must be numeric.")
  assertthat::assert_that(normalize_primary %in% c("none", "height"),
                        msg = "`normalize_primary` must be one of 'none' or 'height'.")

  # Safety checks for sigma0 and rho0 from theta0, consistent with hrf_lwu
  assertthat::assert_that(theta0["sigma"] > 0.05, msg = "sigma in `theta0` must be > 0.05.")
  assertthat::assert_that(theta0["rho"] >= 0 && theta0["rho"] <= 1.5,
                        msg = "rho in `theta0` must be between 0 and 1.5.")

  # Function to pass to numDeriv::grad - parameters must be the first argument
  # and it must return a scalar or vector (hrf_lwu returns a vector of length(t_val))
  target_func_for_grad <- function(params_vec, t_val) {
    hrf_lwu(t = t_val, tau = params_vec[1], sigma = params_vec[2], rho = params_vec[3], normalize = "none")
  }

  # Calculate h0 (the HRF at theta0)
  h0 <- hrf_lwu(t = t, tau = theta0["tau"], sigma = theta0["sigma"], rho = theta0["rho"], normalize = "none")

  if (normalize_primary == "height") {
    max_abs_h0 <- max(abs(h0), na.rm = TRUE)
    if (max_abs_h0 > 1e-10) {
      h0 <- h0 / max_abs_h0
    }
  }

  # Calculate partial derivatives using numDeriv::grad
  # grad() will iterate over each element of `t` if `target_func_for_grad` is vectorized over t,
  # which it is. We want the gradient for each time point.
  # However, numDeriv::grad expects the function to return a single scalar for jacobian calculation.
  # So, we must loop over t points for numDeriv.

  deriv_matrix <- matrix(NA, nrow = length(t), ncol = 3)
  colnames(deriv_matrix) <- c("d_tau", "d_sigma", "d_rho")

  for (i in seq_along(t)) {
    # numDeriv::grad needs a function that takes params and returns a SINGLE value
    # So we create a wrapper for each time point t[i]
    current_t_func <- function(params_vec) {
      hrf_lwu(t = t[i], tau = params_vec[1], sigma = params_vec[2], rho = params_vec[3], normalize = "none")
    }
    # Calculate gradient (vector of 3 partial derivatives) at t[i] w.r.t theta0
    grad_at_t_i <- numDeriv::grad(func = current_t_func, x = theta0)
    deriv_matrix[i, ] <- grad_at_t_i
  }

  basis_mat <- cbind(h0 = h0, deriv_matrix)
  return(basis_mat)
}
</file>

<file path="R/neural_input_methods.R">
#' @rdname neural_input
#' @export
neural_input.Reg <- function(x, start = 0, end = NULL, resolution = 0.33, ...) {
  # Determine end time if not provided
  if (is.null(end)) {
    end <- max(x$onsets + x$duration) + 10  # Add 10 seconds buffer
  }
  
  # Create time vector
  time <- seq(from = start, to = end, by = resolution)
  
  # Initialize neural input vector
  neural <- numeric(length(time))
  
  # For each event, add the amplitude during its duration
  for (i in seq_along(x$onsets)) {
    event_start <- x$onsets[i]
    event_end <- event_start + x$duration[i]
    
    # Find time indices within event duration
    event_indices <- which(time >= event_start & time < event_end)
    
    # Add amplitude for this event
    neural[event_indices] <- neural[event_indices] + x$amplitude[i]
  }
  
  # Return list with time and neural input
  list(time = time, neural_input = neural)
}
</file>

<file path="R/utils-internal.R">
# Put this in R/utils-internal.R
#' @keywords keyword
#' @noRd
recycle_or_error <- function(x, n, name) {
  if (length(x) == n) {
    return(x)
  }
  if (length(x) == 1) {
    return(rep(x, n))
  }
  stop(paste0("`", name, "` must have length 1 or ", n, ", not ", length(x)), call. = FALSE)
}

#' @keywords internal
#' @noRd
`%||%` <- function(a, b) {
  if (is.null(a)) b else a
}
</file>

<file path="tests/testthat/test_acquisition_onsets.R">
context("acquisition_onsets")

test_that("acquisition_onsets returns same values as samples(global=TRUE)", {
  # Single block
  sf1 <- sampling_frame(blocklens = 10, TR = 2)
  expect_equal(acquisition_onsets(sf1), samples(sf1, global = TRUE))
  
  # Multiple blocks
  sf2 <- sampling_frame(blocklens = c(10, 15, 20), TR = 2)
  expect_equal(acquisition_onsets(sf2), samples(sf2, global = TRUE))
  
  # Variable TR
  sf3 <- sampling_frame(blocklens = c(10, 10), TR = c(2, 1.5))
  expect_equal(acquisition_onsets(sf3), samples(sf3, global = TRUE))
})

test_that("acquisition_onsets handles default start_time correctly", {
  # Default start_time = TR/2
  sf <- sampling_frame(blocklens = 5, TR = 2)
  onsets <- acquisition_onsets(sf)
  
  # First onset should be at TR/2 = 1
  expect_equal(onsets[1], 1)
  
  # Spacing should be TR = 2
  expect_equal(diff(onsets), rep(2, 4))
})

test_that("acquisition_onsets handles custom start_time correctly", {
  # start_time = 0
  sf1 <- sampling_frame(blocklens = 5, TR = 2, start_time = 0)
  onsets1 <- acquisition_onsets(sf1)
  expect_equal(onsets1[1], 0)
  expect_equal(onsets1, c(0, 2, 4, 6, 8))
  
  # start_time = 3
  sf2 <- sampling_frame(blocklens = 5, TR = 2, start_time = 3)
  onsets2 <- acquisition_onsets(sf2)
  expect_equal(onsets2[1], 3)
  expect_equal(onsets2, c(3, 5, 7, 9, 11))
  
  # Variable start_time per block
  sf3 <- sampling_frame(blocklens = c(3, 3), TR = 2, start_time = c(0, 5))
  onsets3 <- acquisition_onsets(sf3)
  expect_equal(onsets3[1:3], c(0, 2, 4))      # Block 1
  expect_equal(onsets3[4:6], c(11, 13, 15))   # Block 2 starts at 6 + 5
})

test_that("acquisition_onsets handles variable TR correctly", {
  # Different TR per block
  sf <- sampling_frame(blocklens = c(5, 5), TR = c(2, 3))
  onsets <- acquisition_onsets(sf)
  
  # Block 1: TR=2, start_time=1
  expect_equal(onsets[1:5], c(1, 3, 5, 7, 9))
  
  # Block 2: TR=3, start_time=1.5, starts after block 1 (10 seconds)
  expect_equal(onsets[6:10], c(11.5, 14.5, 17.5, 20.5, 23.5))
})

test_that("acquisition_onsets works with multi-block designs", {
  # Three blocks
  sf <- sampling_frame(blocklens = c(100, 120, 80), TR = 2)
  onsets <- acquisition_onsets(sf)
  
  expect_equal(length(onsets), 300)  # Total scans
  
  # Check transitions between blocks
  # Block 1 ends at: 1 + 99*2 = 199
  expect_equal(onsets[100], 199)
  # Block 2 starts at: 200 + 1 = 201
  expect_equal(onsets[101], 201)
  
  # Block 2 ends at: 201 + 119*2 = 439
  expect_equal(onsets[220], 439)
  # Block 3 starts at: 440 + 1 = 441
  expect_equal(onsets[221], 441)
})

test_that("acquisition_onsets edge cases", {
  # Single scan
  sf1 <- sampling_frame(blocklens = 1, TR = 2)
  expect_equal(acquisition_onsets(sf1), 1)
  
  # Very short TR
  sf2 <- sampling_frame(blocklens = 5, TR = 0.5)
  onsets2 <- acquisition_onsets(sf2)
  expect_equal(onsets2, c(0.25, 0.75, 1.25, 1.75, 2.25))
  
  # Large number of blocks
  sf3 <- sampling_frame(blocklens = rep(10, 10), TR = 1)
  onsets3 <- acquisition_onsets(sf3)
  expect_equal(length(onsets3), 100)
})

test_that("acquisition_onsets matches expected timing for standard fMRI", {
  # Standard fMRI parameters
  sf <- sampling_frame(blocklens = c(150, 150), TR = 2, start_time = 0)
  onsets <- acquisition_onsets(sf)
  
  # Verify timing
  expect_equal(onsets[1], 0)      # First scan at t=0
  expect_equal(onsets[150], 298)  # Last scan of block 1
  expect_equal(onsets[151], 300)  # First scan of block 2
  expect_equal(onsets[300], 598)  # Last scan
  
  # Total duration
  expect_equal(max(onsets), (300-1) * 2)
})
</file>

<file path="tests/testthat/test_hrf_from_coefficients.R">
context("hrf_from_coefficients")

test_that("hrf_from_coefficients combines basis correctly", {
  t <- seq(0, 20, by = 0.5)
  weights <- c(0.5, 2)
  h_combined <- hrf_from_coefficients(HRF_SPMG2, weights, name = "combined")
  expect_s3_class(h_combined, "HRF")
  expect_equal(nbasis(h_combined), 1L)
  expect_equal(attr(h_combined, "name"), "combined")

  expected <- as.numeric(HRF_SPMG2(t) %*% weights)
  result <- h_combined(t)
  expect_equal(result, expected)
})
</file>

<file path="tests/testthat/test_hrf_library.R">
library(testthat)

# simple generator that records scale
make_gauss <- function(mean=0, sd=1, scale=1) {
  as_hrf(function(t) scale * dnorm(t, mean, sd),
         name = paste0("gauss_", mean),
         nbasis = 1L)
}


test_that("hrf_library forwards extra arguments", {
  pgrid <- data.frame(mean = c(0, 2), sd = c(1, 1))
  lib <- hrf_library(make_gauss, pgrid, scale = 2)
  expect_s3_class(lib, "HRF")
  expect_equal(nbasis(lib), 2)
  t <- c(0, 1)
  expected <- cbind(2 * dnorm(t, 0, 1), 2 * dnorm(t, 2, 1))
  expect_equal(lib(t), expected)
})


test_that("duplicate parameter names cause an error", {
  pgrid <- data.frame(mean = 0, sd = 1, scale = 1)
  expect_error(hrf_library(make_gauss, pgrid, scale = 2))
})
</file>

<file path="tests/testthat/test_penalty_matrix.R">
context("penalty_matrix")

library(testthat)

test_that("bspline penalty is roughness-based", {
  R <- penalty_matrix(HRF_BSPLINE)
  expect_false(identical(R, diag(nbasis(HRF_BSPLINE))))
  expect_equal(nrow(R), nbasis(HRF_BSPLINE))
})

test_that("SPMG3 penalty shrinks derivatives", {
  R <- penalty_matrix(HRF_SPMG3, shrink_deriv = 4)
  expect_equal(R[1,1], 0)
  expect_equal(R[2,2], 4)
  expect_equal(R[3,3], 4)
})

test_that("fourier penalty increases with frequency", {
  fhrf <- hrf_fourier_generator(nbasis = 4, span = 24)
  R <- penalty_matrix(fhrf)
  expect_equal(diag(R), c(1,1,4,4))
})

test_that("default HRF penalty is identity", {
  R <- penalty_matrix(HRF_GAUSSIAN)
  expect_equal(R, diag(nbasis(HRF_GAUSSIAN)))
})
</file>

<file path="tests/testthat/test_reg_constructor.R">
context("Reg constructor and single_trial_regressor")

library(testthat)

# Verify Reg error handling

test_that("Reg validates inputs", {
  expect_error(Reg(onsets = -1), "onsets")
  expect_error(Reg(onsets = c(0, NA)), "onsets")
  expect_error(Reg(onsets = 1, span = 0), "span")
  expect_error(Reg(onsets = c(0,1), duration = c(1,2,3)), "duration")
  expect_error(Reg(onsets = c(0,1), amplitude = c(1,2,3)), "amplitude")
})

# Verify single_trial_regressor construction and errors

test_that("single_trial_regressor constructs single event", {
  st <- single_trial_regressor(onsets = 5, duration = 2, amplitude = 3)
  expect_s3_class(st, "Reg")
  expect_equal(length(st$onsets), 1)
  expect_equal(st$onsets, 5)
  expect_equal(st$duration, 2)
  expect_equal(st$amplitude, 3)
})

test_that("single_trial_regressor validates lengths", {
  expect_error(single_trial_regressor(onsets = c(1,2)), "onsets")
  expect_error(single_trial_regressor(onsets = 1, duration = c(1,2)), "duration")
  expect_error(single_trial_regressor(onsets = 1, amplitude = c(1,2)), "amplitude")
})
</file>

<file path="tests/testthat/test_regressor_design.R">
box_hrf_fun <- function(t) ifelse(t >= 0 & t <= 1, 1, 0)
BOX_HRF <- as_hrf(box_hrf_fun, name = "box", span = 1)

# Basic construction and evaluation with sampling frame

test_that("regressor_design produces expected design", {
  ons <- c(0, 1, 0, 2)
  fac <- factor(c("a", "b", "a", "b"))
  blk <- c(1L, 1L, 2L, 2L)
  sf  <- sampling_frame(blocklens = c(3, 3), TR = 1)
  dmat <- regressor_design(ons, fac, blk, sf, hrf = BOX_HRF, precision = 1)
  expect_true(is.matrix(dmat))
  expect_equal(nrow(dmat), length(samples(sf)))
  expect_equal(ncol(dmat), nbasis(BOX_HRF) * length(levels(fac)))
})

# Sparse output

test_that("regressor_design returns sparse matrix", {
  ons <- c(0, 2)
  fac <- factor(c("a", "b"))
  blk <- c(1L, 2L)
  sf  <- sampling_frame(blocklens = c(3, 3), TR = 1)
  dmat <- regressor_design(ons, fac, blk, sf, hrf = BOX_HRF,
                           precision = 1, sparse = TRUE)
  expect_true(inherits(dmat, "dgCMatrix"))
})
</file>

<file path="tests/testthat/test_regressor_set.R">
box_hrf_fun <- function(t) ifelse(t >= 0 & t <= 1, 1, 0)
BOX_HRF <- as_hrf(box_hrf_fun, name = "box", span = 1)

# Basic construction and evaluation

test_that("regressor_set constructs and evaluates", {
  ons <- c(0, 1, 2, 3)
  fac <- factor(c("a", "a", "b", "b"))
  rs <- regressor_set(ons, fac, hrf = BOX_HRF)
  expect_s3_class(rs, "RegSet")
  grid <- 0:4
  mat <- evaluate(rs, grid, method = "conv", precision = 1)
  expect_true(is.matrix(mat))
  expect_equal(nrow(mat), length(grid))
  expect_equal(ncol(mat), nbasis(BOX_HRF) * length(levels(fac)))
})

# Sparse output

test_that("regressor_set produces sparse matrix", {
  ons <- c(0, 2)
  fac <- factor(c("a", "b"))
  rs <- regressor_set(ons, fac, hrf = BOX_HRF)
  grid <- 0:4
  mat <- evaluate(rs, grid, method = "conv", precision = 1, sparse = TRUE)
  expect_true(inherits(mat, "dgCMatrix"))
})
</file>

<file path="tests/testthat/test_utils.R">
context("utility functions")

test_that("recycle_or_error recycles or errors correctly", {
  expect_equal(recycle_or_error(5, 3, "val"), rep(5,3))
  expect_equal(recycle_or_error(c(1,2,3), 3, "val"), c(1,2,3))
  expect_error(recycle_or_error(c(1,2), 3, "val"), "length 1 or 3")
})
</file>

<file path="R/fmrihrf-package.R">
#' @details
#' The fmrihrf package provides tools for creating, manipulating, and evaluating
#' Hemodynamic Response Functions (HRFs) and event-related regressors
#' for fMRI data analysis.
#'
#' @keywords internal
"_PACKAGE"

#' @useDynLib fmrihrf, .registration = TRUE
#' @importFrom Rcpp sourceCpp
NULL
</file>

<file path="R/penalty_matrix_methods.R">
#' @rdname penalty_matrix
#' @export
penalty_matrix.HRF <- function(x, order = 2, ...) {
  diag(nbasis(x))
}

# internal helper for roughness penalties
roughness_penalty <- function(nb, order = 2) {
  if (nb <= 1) {
    diag(nb)
  } else if (nb > order) {
    D <- diff(diag(nb), differences = order)
    crossprod(D)
  } else {
    diag(nb)
  }
}

#' @rdname penalty_matrix
#' @export
penalty_matrix.BSpline_HRF <- function(x, order = 2, ...) {
  roughness_penalty(nbasis(x), order)
}

#' @rdname penalty_matrix
#' @export
penalty_matrix.Tent_HRF <- function(x, order = 2, ...) {
  roughness_penalty(nbasis(x), order)
}

#' @rdname penalty_matrix
#' @export
penalty_matrix.FIR_HRF <- function(x, order = 2, ...) {
  roughness_penalty(nbasis(x), order)
}

#' @rdname penalty_matrix
#' @export
penalty_matrix.SPMG2_HRF <- function(x, order = 2, shrink_deriv = 2, ...) {
  nb <- nbasis(x)
  R <- diag(nb)
  if (nb >= 1) R[1, 1] <- 0
  if (nb >= 2) R[2, 2] <- shrink_deriv
  R
}

#' @rdname penalty_matrix
#' @export
penalty_matrix.SPMG3_HRF <- function(x, order = 2, shrink_deriv = 2, ...) {
  nb <- nbasis(x)
  R <- diag(nb)
  if (nb >= 1) R[1, 1] <- 0
  if (nb >= 2) R[2, 2] <- shrink_deriv
  if (nb >= 3) R[3, 3] <- shrink_deriv
  R
}

#' @rdname penalty_matrix
#' @export
penalty_matrix.Fourier_HRF <- function(x, order = 2, ...) {
  nb <- nbasis(x)
  freqs <- ceiling(seq_len(nb) / 2)
  diag(freqs^order)
}

#' @rdname penalty_matrix
#' @export
penalty_matrix.Daguerre_HRF <- function(x, order = 2, ...) {
  nb <- nbasis(x)
  diag((seq_len(nb) - 1)^2)
}
</file>

<file path="R/regressor-design.R">
#' Build a Design Matrix from Block-wise Onsets
#'
#' `regressor_design` extends [regressor_set()] by allowing onsets to be
#' specified relative to individual blocks and by directly returning the
#' evaluated design matrix.
#'
#' @param onsets Numeric vector of event onset times, expressed relative to the
#'   start of their corresponding block.
#' @param fac A factor (or object coercible to a factor) indicating the
#'   condition for each onset.
#' @param block Integer vector identifying the block for each onset. Values must
#'   be valid block indices for `sframe`.
#' @param sframe A [sampling_frame] describing the temporal structure of the
#'   experiment.
#' @param hrf Hemodynamic response function shared by all conditions.
#' @param duration Numeric scalar or vector of event durations.
#' @param amplitude Numeric scalar or vector of event amplitudes.
#' @param span Numeric scalar giving the HRF span in seconds.
#' @param precision Numeric precision used during convolution.
#' @param method Evaluation method passed to [evaluate()].
#' @param sparse Logical; if `TRUE` a sparse design matrix is returned.
#' @param summate Logical; passed to [regressor()].
#'
#' @return A numeric matrix (or sparse matrix) with one column per factor level
#'   and one row per sample defined by `sframe`.
#' @examples
#' # Create a sampling frame for 2 blocks, 100 scans each, TR=2
#' sframe <- sampling_frame(blocklens = c(100, 100), TR = 2)
#' 
#' # Events in block-relative time
#' onsets <- c(10, 30, 50, 20, 40, 60)
#' conditions <- factor(c("A", "B", "A", "B", "A", "B"))
#' blocks <- c(1, 1, 1, 2, 2, 2)
#' 
#' # Build design matrix
#' design <- regressor_design(
#'   onsets = onsets,
#'   fac = conditions,
#'   block = blocks,
#'   sframe = sframe,
#'   hrf = HRF_SPMG1
#' )
#' 
#' # Design matrix has 200 rows (total scans) and 2 columns (conditions)
#' dim(design)
#' @export
regressor_design <- function(onsets, fac, block, sframe,
                             hrf = HRF_SPMG1, duration = 0,
                             amplitude = 1, span = 40,
                             precision = .33,
                             method = c("conv", "fft", "Rconv", "loop"),
                             sparse = FALSE,
                             summate = TRUE) {
  fac   <- as.factor(fac)
  block <- as.integer(block)

  if (length(onsets) != length(fac) || length(onsets) != length(block)) {
    stop("`onsets`, `fac` and `block` must have the same length", call. = FALSE)
  }

  method <- match.arg(method)

  # Convert block-wise onsets to global timing
  g_onsets <- global_onsets(sframe, onsets, block)

  # Create regressor set using global onsets
  rs <- regressor_set(g_onsets, fac, hrf = hrf,
                      duration = duration, amplitude = amplitude,
                      span = span, summate = summate)

  # Evaluation grid corresponds to all acquisition times
  grid <- samples(sframe, global = TRUE)

  evaluate(rs, grid = grid, precision = precision,
           method = method, sparse = sparse)
}
</file>

<file path="tests/testthat/test_fft_and_toeplitz.R">
context("FFT evaluation and HRF Toeplitz")

library(testthat)

# Helper HRF for Toeplitz and regressor tests
box_hrf_fun <- function(t) ifelse(t >= 0 & t <= 1, 1, 0)
BOX_HRF <- as_hrf(box_hrf_fun, name = "box", span = 1)


test_that("evaluate.Reg fft method matches conv", {
  reg <- regressor(onsets = c(0, 2), hrf = BOX_HRF, span = 1)
  grid <- seq(0, 4, by = 0.5)
  res_fft <- evaluate(reg, grid, method = "fft", precision = 0.1)
  res_conv <- evaluate(reg, grid, method = "conv", precision = 0.1)
  expect_equal(res_fft, res_conv, tolerance = 1e-6)
})

manual_toeplitz <- function(col, row) {
  nr <- length(col)
  nc <- length(row)
  out <- matrix(0, nr, nc)
  for (i in seq_len(nr)) {
    for (j in seq_len(nc)) {
      if (i >= j) {
        out[i, j] <- col[i - j + 1]
      } else {
        out[i, j] <- row[j - i + 1]
      }
    }
  }
  out
}


test_that("hrf_toeplitz constructs correct Toeplitz matrix", {
  time <- 0:2
  len <- 5
  H_dense <- hrf_toeplitz(BOX_HRF, time, len, sparse = FALSE)
  hreg <- BOX_HRF(time)
  col <- c(hreg, rep(0, len - length(hreg)))
  row <- c(hreg[1], rep(0, len - 1))
  expected <- manual_toeplitz(col, row)
  expect_true(inherits(H_dense, "Matrix"))
  expect_equal(as.matrix(H_dense), expected)

  H_sparse <- hrf_toeplitz(BOX_HRF, time, len, sparse = TRUE)
  expect_s4_class(H_sparse, "Matrix")
  expect_equal(as.matrix(H_sparse), expected)
})
</file>

<file path="tests/testthat/test_hrf_lwu_extra.R">
context("hrf_lwu and related functions")

test_that("hrf_lwu computes response and normalisation", {
  t <- seq(0, 20, by = 0.5)
  raw <- hrf_lwu(t, tau = 6, sigma = 2, rho = 0.4)
  expect_equal(length(raw), length(t))
  expect_true(is.numeric(raw))

  # height normalisation
  norm <- hrf_lwu(t, tau = 6, sigma = 2, rho = 0.4, normalize = "height")
  expect_equal(max(abs(norm)), 1)

  # area normalisation currently behaves like none and warns
  expect_warning(area <- hrf_lwu(t, tau = 6, sigma = 2, rho = 0.4, normalize = "area"))
  expect_equal(area, raw)
})


test_that("hrf_basis_lwu returns derivatives", {
  theta <- c(tau = 6, sigma = 2, rho = 0.4)
  t <- seq(0, 20, by = 1)
  basis <- hrf_basis_lwu(theta, t)
  expect_equal(dim(basis), c(length(t), 4))
  expect_equal(basis[, "h0"], hrf_lwu(t, tau = theta["tau"], sigma = theta["sigma"], rho = theta["rho"]))

  # finite-difference check of derivative w.r.t tau at one point
  delta <- 1e-4
  t0 <- 4
  fd_tau <- (hrf_lwu(t0, tau = theta["tau"] + delta, sigma = theta["sigma"], rho = theta["rho"]) -
              hrf_lwu(t0, tau = theta["tau"] - delta, sigma = theta["sigma"], rho = theta["rho"])) / (2 * delta)
  idx <- which(t == t0)
  expect_equal(as.numeric(basis[idx, "d_tau"]), as.numeric(fd_tau), tolerance = 1e-3)
})
</file>

<file path="DESCRIPTION">
Package: fmrihrf
Type: Package
Title: fMRI Hemodynamic Response Function (HRF) and Regressor Tools
Version: 0.1.0
Authors@R: person("Bradley", "Buchsbaum", email = "brad.buchsbaum@gmail.com", role = c("aut", "cre"))
Description: Provides tools for creating, manipulating, and evaluating
    Hemodynamic Response Functions (HRFs) and event-related regressors
    for fMRI data analysis. Includes functions for generating various HRF
    basis sets, applying decorators (e.g., lag, block), and convolving
    regressors with HRFs.
License: MIT + file LICENSE
Encoding: UTF-8
LazyData: true
RoxygenNote: 7.3.2.9000
Imports:
    Rcpp,
    assertthat,
    purrr,
    stats,
    Matrix,
    cli,
    memoise,
    numDeriv,
    rlang,
    splines,
    pracma
LinkingTo: Rcpp, RcppArmadillo
Depends:
    R (>= 3.5.0)
Suggests:
    testthat (>= 3.0.0),
    knitr,
    rmarkdown,
    ggplot2,
    dplyr,
    tidyr,
    viridis,
    scales
VignetteBuilder: knitr
URL: https://bbuchsbaum.github.io/fmrihrf/
</file>

<file path="R/regressor-set.R">
#' Construct a Regressor Set
#'
#' Creates a set of regressors, one for each level of a factor. Each
#' condition shares the same HRF and other parameters but has distinct
#' onsets, durations and amplitudes.
#'
#' @param onsets Numeric vector of event onset times.
#' @param fac A factor (or object coercible to a factor) indicating the
#'   condition for each onset.
#' @param hrf Hemodynamic response function used for all conditions.
#' @param duration Numeric scalar or vector of event durations.
#' @param amplitude Numeric scalar or vector of event amplitudes.
#' @param span Numeric scalar giving the HRF span in seconds.
#' @param summate Logical; passed to [regressor()].
#'
#' @return An object of class `RegSet` containing one `Reg` per factor level.
#' @examples
#' # Create events for 3 conditions
#' onsets <- c(10, 20, 30, 40, 50, 60)
#' conditions <- factor(c("A", "B", "C", "A", "B", "C"))
#' 
#' # Create regressor set
#' rset <- regressor_set(onsets, conditions, hrf = HRF_SPMG1)
#' 
#' # With durations and amplitudes
#' rset2 <- regressor_set(
#'   onsets = onsets,
#'   fac = conditions,
#'   duration = 2,
#'   amplitude = c(1, 1.5, 0.8, 1, 1.5, 0.8),
#'   hrf = HRF_SPMG1
#' )
#' 
#' # Evaluate the regressor set
#' times <- seq(0, 80, by = 0.1)
#' design_matrix <- evaluate(rset, times)
#' @export
regressor_set <- function(onsets, fac, hrf = HRF_SPMG1, duration = 0,
                          amplitude = 1, span = 40, summate = TRUE) {
  fac <- as.factor(fac)
  onsets    <- as.numeric(onsets)
  duration  <- recycle_or_error(as.numeric(duration), length(onsets), "duration")
  amplitude <- recycle_or_error(as.numeric(amplitude), length(onsets), "amplitude")
  if (length(fac) != length(onsets)) {
    stop("`fac` must be the same length as `onsets`", call. = FALSE)
  }
  levs <- levels(fac)
  regs <- lapply(levs, function(lv) {
    idx <- which(fac == lv)
    if (length(idx) == 0) {
      null_regressor(hrf = hrf, span = span)
    } else {
      Reg(onsets = onsets[idx], hrf = hrf,
          duration = duration[idx], amplitude = amplitude[idx],
          span = span, summate = summate)
    }
  })
  structure(list(regs = regs, levels = levs), class = c("RegSet", "list"))
}

#' @rdname regressor_set
#' @param x A RegSet object
#' @param grid Numeric vector of time points at which to evaluate
#' @param precision Numeric precision for evaluation
#' @param method Evaluation method
#' @param sparse Logical whether to return sparse matrix
#' @param ... Additional arguments passed to evaluate
#' @export
evaluate.RegSet <- function(x, grid, precision = .33,
                            method = c("conv", "fft", "Rconv", "loop"),
                            sparse = FALSE, ...) {
  method <- match.arg(method)
  mats <- lapply(x$regs, evaluate, grid = grid, precision = precision,
                 method = method, sparse = FALSE, ...)
  out <- do.call(cbind, mats)
  if (sparse) {
    return(Matrix::Matrix(out, sparse = TRUE))
  } else {
    return(out)
  }
}
</file>

<file path="R/hrf_decorators.R">
#' Lag an HRF Object
#'
#' Creates a new HRF object by applying a temporal lag to an existing HRF object.
#'
#' @param hrf The HRF object (of class `HRF`) to lag.
#' @param lag The time lag in seconds to apply. Positive values shift the response later in time.
#'
#' @return A new HRF object representing the lagged function.
#'
#' @family HRF_decorator_functions
#' @export
#' @examples
#' lagged_spmg1 <- lag_hrf(HRF_SPMG1, 5)
#' # Evaluate at time 10; equivalent to HRF_SPMG1(10 - 5)
#' lagged_spmg1(10)
#' HRF_SPMG1(5)
lag_hrf <- function(hrf, lag) {
  assertthat::assert_that(inherits(hrf, "HRF"), msg = "Input 'hrf' must be an HRF object.")
  assertthat::assert_that(
    is.numeric(lag) && length(lag) == 1 && is.finite(lag),
    msg = "'lag' must be a single finite numeric value."
  )

  # Original attributes
  orig_name <- attr(hrf, "name")
  orig_span <- attr(hrf, "span")
  orig_nbasis <- nbasis(hrf)
  orig_params <- attr(hrf, "params")

  # Create the lagged function
  lagged_func <- function(t) {
    hrf(t - lag)
  }

  # Create new HRF object using as_hrf
  as_hrf(
    f = lagged_func,
    name = paste0(orig_name, "_lag(", lag, ")"),
    nbasis = orig_nbasis,
    span = orig_span + max(0, lag), # Increase span if lag is positive
    params = c(orig_params, list(.lag = lag)) # Add lag to params for bookkeeping
  )
}


#' Create a Blocked HRF Object
#'
#' Creates a new HRF object representing a response to a sustained (blocked)
#' stimulus by convolving the input HRF with a boxcar function of a given width.
#'
#' @param hrf The HRF object (of class `HRF`) to block.
#' @param width The width of the block in seconds.
#' @param precision The sampling precision in seconds used for the internal convolution (default: 0.1).
#' @param half_life The half-life of an optional exponential decay applied during the block (default: Inf, meaning no decay).
#' @param summate Logical; if TRUE (default), the responses from each time point within the block are summed. If FALSE, the maximum response at each time point is taken.
#' @param normalize Logical; if TRUE, the resulting blocked HRF is scaled so that its peak value is 1 (default: FALSE).
#'
#' @return A new HRF object representing the blocked function.
#'
#' @family HRF_decorator_functions
#' @export
#' @examples
#' blocked_spmg1 <- block_hrf(HRF_SPMG1, width = 5)
#' t_vals <- seq(0, 30, by = 0.5)
#' plot(t_vals, HRF_SPMG1(t_vals), type = 'l', col = "blue", ylab = "Response", xlab = "Time")
#' lines(t_vals, blocked_spmg1(t_vals), col = "red")
#' legend("topright", legend = c("Original", "Blocked (width=5)"), col = c("blue", "red"), lty = 1)
block_hrf <- function(hrf, width, precision = 0.1, half_life = Inf, summate = TRUE, normalize = FALSE) {
  assertthat::assert_that(inherits(hrf, "HRF"), msg = "Input 'hrf' must be an HRF object.")
  assertthat::assert_that(
    is.numeric(width) && length(width) == 1 && width >= 0 && is.finite(width),
    msg = "'width' must be a single non-negative finite numeric value."
  )
  assertthat::assert_that(
    is.numeric(precision) && length(precision) == 1 && precision > 0 && is.finite(precision),
    msg = "'precision' must be a single finite positive numeric value."
  )
  assertthat::assert_that(
    is.numeric(half_life) && length(half_life) == 1 && half_life > 0,
    msg = "'half_life' must be a single positive numeric value."
  )
  assertthat::assert_that(is.logical(summate) && length(summate) == 1, msg = "'summate' must be a single logical value.")
  assertthat::assert_that(is.logical(normalize) && length(normalize) == 1, msg = "'normalize' must be a single logical value.")

  # Original attributes
  orig_name <- attr(hrf, "name")
  orig_span <- attr(hrf, "span")
  orig_nbasis <- nbasis(hrf)
  orig_params <- attr(hrf, "params")

  # Create the blocked function
  blocked_func <- function(t) {
    if (width < precision) {
      # If width is negligible, just return the original hrf value
      res <- hrf(t)
    } else {
      samples <- seq(0, width, by = precision)
      hmat_list <- lapply(samples, function(offset) {
        decay_factor <- if (is.infinite(half_life)) 1 else exp(-log(2) * offset / half_life)
        hrf(t - offset) * decay_factor
      })
      
      # Combine results for each time point t across offsets
      if (orig_nbasis == 1) {
        hmat <- do.call(cbind, hmat_list) # Matrix with rows=time, cols=offsets
        res <- if (summate) {
          rowSums(hmat)
        } else {
          apply(hmat, 1, function(vals) vals[which.max(vals)])
        }
      } else {
         # For multi-basis, sum matrices if summate=TRUE (difficult to define max sensibly)
         if (!summate) {
           warning("'summate = FALSE' is not fully supported for multi-basis HRFs in block_hrf; returning sum.")
         }
         res <- Reduce("+", hmat_list)
      }
    }
    
    # Apply normalization if requested
    if (normalize) {
      if (orig_nbasis == 1) {
        peak_val <- max(abs(res), na.rm = TRUE)
        if (!is.na(peak_val) && peak_val != 0) {
          res <- res / peak_val
        }
      } else {
        # Normalize each basis column independently
        res <- apply(res, 2, function(basis_col) {
           peak_val <- max(abs(basis_col), na.rm = TRUE)
           if (!is.na(peak_val) && peak_val != 0) {
             basis_col / peak_val
           } else {
             basis_col
           }
        })
      }
    }
    return(res)
  }

  # Store parameters used for blocking
  block_params <- list(
      .width = width,
      .precision = precision,
      .half_life = half_life,
      .summate = summate,
      .normalize = normalize
  )
  
  # Create new HRF object using as_hrf
  as_hrf(
    f = blocked_func,
    name = paste0(orig_name, "_block(w=", width, ")"),
    nbasis = orig_nbasis,
    span = orig_span + width, # Span increases by the block width
    params = c(orig_params, block_params) # Add block params for bookkeeping
  )
}


#' Normalise an HRF Object
#'
#' Creates a new HRF object whose output is scaled such that the maximum absolute
#' value of the response is 1.
#'
#' @param hrf The HRF object (of class `HRF`) to normalise.
#'
#' @return A new HRF object representing the normalised function.
#' @details For multi-basis HRFs, each basis function (column) is normalised independently.
#'
#' @family HRF_decorator_functions
#' @export
#' @examples
#' # Create a gaussian HRF with a peak value != 1
#' gauss_unnorm <- as_hrf(function(t) 5 * dnorm(t, 6, 2), name="unnorm_gauss")
#' # Normalise it
#' gauss_norm <- normalise_hrf(gauss_unnorm)
#' t_vals <- seq(0, 20, by = 0.1)
#' max(gauss_unnorm(t_vals)) # Peak is > 1
#' max(gauss_norm(t_vals))   # Peak is 1
normalise_hrf <- function(hrf) {
  assertthat::assert_that(inherits(hrf, "HRF"), msg = "Input 'hrf' must be an HRF object.")

  # Original attributes
  orig_name <- attr(hrf, "name")
  orig_span <- attr(hrf, "span")
  orig_nbasis <- nbasis(hrf)
  orig_params <- attr(hrf, "params")

  # Create the normalised function
  normalised_func <- function(t) {
    res <- hrf(t)
    if (orig_nbasis == 1) {
      peak_val <- max(abs(res), na.rm = TRUE)
      if (!is.na(peak_val) && peak_val != 0) {
        res <- res / peak_val
      }
    } else if (is.matrix(res)) {
      # Normalise each basis column independently while preserving matrix shape
      peaks <- apply(res, 2, function(basis_col) {
        max(abs(basis_col), na.rm = TRUE)
      })
      peaks_safe <- ifelse(is.na(peaks) | peaks == 0, 1, peaks)
      res <- sweep(res, 2, peaks_safe, "/")
    }
    # If it's not numeric or matrix (e.g., NULL or error result), return as is
    return(res)
  }

  # Create new HRF object using as_hrf
  as_hrf(
    f = normalised_func,
    name = paste0(orig_name, "_norm"),
    nbasis = orig_nbasis,
    span = orig_span,
    params = c(orig_params, list(.normalised = TRUE)) # Add flag for bookkeeping
  )
}
</file>

<file path="tests/testthat/test_hrf.R">
library(testthat)

test_that("HRF_GAMMA has correct structure and properties", {
  # Test basic structure
  expect_true(inherits(HRF_GAMMA, "HRF"))
  expect_equal(attr(HRF_GAMMA, "name"), "gamma")
  expect_equal(attr(HRF_GAMMA, "param_names"), c("shape", "rate"))
  
  # Test function evaluation
  t <- seq(0, 20, by=0.5)
  result <- HRF_GAMMA(t)
  expect_true(is.numeric(result))
  expect_equal(length(result), length(t))
  expect_true(all(result >= 0))  # Gamma HRF should be non-negative
})

test_that("HRF_SPMG1 has correct structure and properties", {
  # Test basic structure
  expect_true(inherits(HRF_SPMG1, "HRF"))
  expect_equal(attr(HRF_SPMG1, "name"), "SPMG1")
  expect_equal(attr(HRF_SPMG1, "param_names"), c("P1", "P2", "A1"))
  
  # Test function evaluation
  t <- seq(0, 30, by=0.5)
  result <- HRF_SPMG1(t)
  expect_true(is.numeric(result))
  expect_equal(length(result), length(t))
  expect_equal(result[t < 0], rep(0, sum(t < 0)))  # Should be 0 for negative time
  
  # Test peak timing (should peak around 5-6 seconds)
  peak_time <- t[which.max(result)]
  expect_true(peak_time >= 4 && peak_time <= 7)
})

test_that("HRF_SPMG2 has correct structure and properties", {
  # Test basic structure
  expect_true(inherits(HRF_SPMG2, "HRF"))
  expect_equal(attr(HRF_SPMG2, "name"), "SPMG2")
  expect_equal(nbasis(HRF_SPMG2), 2)  # Should have 2 basis functions
  
  # Test function evaluation
  t <- seq(0, 30, by=0.5)
  result <- HRF_SPMG2(t)
  expect_true(is.matrix(result))
  expect_equal(nrow(result), length(t))
  expect_equal(ncol(result), 2)  # Should return 2 columns for canonical and temporal derivative
})

test_that("HRF_GAUSSIAN has correct structure and properties", {
  # Test basic structure
  expect_true(inherits(HRF_GAUSSIAN, "HRF"))
  expect_equal(attr(HRF_GAUSSIAN, "name"), "gaussian")
  expect_equal(attr(HRF_GAUSSIAN, "param_names"), c("mean", "sd"))
  
  # Test function evaluation
  t <- seq(0, 20, by=0.5)
  result <- HRF_GAUSSIAN(t)
  expect_true(is.numeric(result))
  expect_equal(length(result), length(t))
  expect_true(all(result >= 0))  # Gaussian HRF should be non-negative
})

test_that("HRF_BSPLINE has correct structure and properties", {
  # Test basic structure
  expect_true(inherits(HRF_BSPLINE, "HRF"))
  expect_equal(attr(HRF_BSPLINE, "name"), "bspline")
  expect_equal(nbasis(HRF_BSPLINE), 5)  # Default number of basis functions
  
  # Test function evaluation
  t <- seq(0, 20, by=0.5)
  result <- HRF_BSPLINE(t)
  expect_true(is.matrix(result))
  expect_equal(nrow(result), length(t))
  expect_equal(ncol(result), 5)  # Should return 5 columns for basis functions
})

test_that("evaluate.HRF handles different duration scenarios", {
  t <- seq(0, 20, by=0.2)
  
  # Test zero duration
  result1 <- evaluate(HRF_SPMG1, t, duration=0)
  expect_true(is.numeric(result1))
  expect_equal(length(result1), length(t))
})

test_that("gen_hrf handles lag and width correctly", {
  # Test lag
  hrf_lag <- gen_hrf(HRF_SPMG1, lag = 2)
  t <- seq(0, 20, by = 0.5)
  result_lag <- hrf_lag(t)
  result_no_lag <- HRF_SPMG1(t)
  
  # Peak should be shifted by lag
  peak_lag <- t[which.max(result_lag)]
  peak_no_lag <- t[which.max(result_no_lag)]
  expect_equal(peak_lag - peak_no_lag, 2)
  
  # Test width (block duration)
  hrf_block <- gen_hrf(HRF_SPMG1, width = 3)
  result_block <- hrf_block(t)
  
  # Block HRF should have wider response
  width_block <- sum(result_block > 0)
  width_no_block <- sum(result_no_lag > 0)
  expect_true(width_block > width_no_block)
  
  # Test combined lag and width
  hrf_both <- gen_hrf(HRF_SPMG1, lag = 2, width = 3)
  result_both <- hrf_both(t)
  peak_both <- t[which.max(result_both)]
  expect_true(peak_both > peak_no_lag)
})

test_that("gen_hrf_set combines HRFs correctly", {
  # Create basis set
  hrf1 <- gen_hrf(HRF_SPMG1, lag = 0)
  hrf2 <- gen_hrf(HRF_SPMG1, lag = 2)
  hrf3 <- gen_hrf(HRF_SPMG1, lag = 4)
  hrf_set <- gen_hrf_set(hrf1, hrf2, hrf3, name = "test_set")
  
  # Test structure
  expect_true(inherits(hrf_set, "HRF"))
  expect_equal(nbasis(hrf_set), 3)
  expect_equal(attr(hrf_set, "name"), "test_set")
  
  # Test evaluation
  t <- seq(0, 20, by = 0.5)
  result <- hrf_set(t)
  expect_true(is.matrix(result))
  expect_equal(dim(result), c(length(t), 3))
  
  # Test peaks are correctly shifted
  peaks <- apply(result, 2, function(x) t[which.max(x)])
  expect_equal(diff(peaks), c(2, 2))
})

test_that("evaluate.HRF handles different durations and summation correctly", {
  t <- seq(0, 20, by = 0.2)
  
  # Test non-zero duration
  result_dur <- evaluate(HRF_SPMG1, t, duration = 2)
  result_no_dur <- evaluate(HRF_SPMG1, t, duration = 0)
  
  # Response should be larger with duration
  expect_true(max(result_dur) > max(result_no_dur))
  
  # Test summation
  result_sum <- evaluate(HRF_SPMG1, t, duration = 2, summate = TRUE)
  result_no_sum <- evaluate(HRF_SPMG1, t, duration = 2, summate = FALSE)
  expect_false(identical(result_sum, result_no_sum))
  
  # Test precision effects
  result_fine <- evaluate(HRF_SPMG1, t, duration = 2, precision = 0.1)
  result_coarse <- evaluate(HRF_SPMG1, t, duration = 2, precision = 0.5)
  expect_false(identical(result_fine, result_coarse))
})

test_that("gen_empirical_hrf creates valid HRF", {
  # Create simple empirical HRF
  t <- seq(0, 20, by = 0.5)
  y <- dnorm(t, mean = 6, sd = 2)
  hrf <- gen_empirical_hrf(t, y, name = "test_empirical")
  
  # Test structure
  expect_true(inherits(hrf, "HRF"))
  expect_equal(attr(hrf, "name"), "test_empirical")
  expect_equal(nbasis(hrf), 1)
  
  # Test interpolation
  new_t <- seq(0, 20, by = 0.3)
  result <- hrf(new_t)
  expect_equal(length(result), length(new_t))
  expect_true(all(result >= 0))
  
  # Test extrapolation
  extended_t <- c(-2, t, 22)
  result_ext <- hrf(extended_t)
  expect_equal(result_ext[1], 0)  # Left extrapolation
  expect_equal(result_ext[length(result_ext)], 0)  # Right extrapolation
})

test_that("HRF objects maintain correct attributes", {
  # Test basic HRF attributes
  t <- seq(0, 20, by = 0.5)
  
  hrfs <- list(
    HRF_SPMG1 = HRF_SPMG1,
    HRF_SPMG2 = HRF_SPMG2,
    HRF_GAMMA = HRF_GAMMA,
    HRF_GAUSSIAN = HRF_GAUSSIAN
  )
  
  for (name in names(hrfs)) {
    hrf <- hrfs[[name]]
    expect_true(inherits(hrf, "HRF"))
    expect_true(is.function(hrf))
    expect_true(!is.null(attr(hrf, "span")))
    expect_true(!is.null(attr(hrf, "nbasis")))
    expect_true(!is.null(attr(hrf, "name")))
    
    # Test evaluation produces correct dimensions
    result <- hrf(t)
    if (attr(hrf, "nbasis") == 1) {
      expect_true(is.numeric(result))
      expect_equal(length(result), length(t))
    } else {
      expect_true(is.matrix(result))
      expect_equal(nrow(result), length(t))
      expect_equal(ncol(result), attr(hrf, "nbasis"))
    }
  }
})

test_that("as_hrf creates valid HRF objects", {
  # Simple function
  my_func <- function(t) { t^2 }
  
  # Create HRF using as_hrf
  hrf_obj <- as_hrf(my_func, name = "test_sq", nbasis = 1L, span = 10, 
                      params = list(power = 2))
  
  # Check class
  expect_true(inherits(hrf_obj, "HRF"))
  expect_true(inherits(hrf_obj, "function"))
  
  # Check attributes
  expect_equal(attr(hrf_obj, "name"), "test_sq")
  expect_equal(attr(hrf_obj, "nbasis"), 1L)
  expect_equal(attr(hrf_obj, "span"), 10)
  expect_equal(attr(hrf_obj, "param_names"), "power")
  expect_equal(attr(hrf_obj, "params"), list(power = 2))
  
  # Check function evaluation
  expect_equal(hrf_obj(5), 25)
  
  # Check defaults
  hrf_obj_default <- as_hrf(my_func)
  expect_equal(attr(hrf_obj_default, "name"), "my_func")
  expect_equal(attr(hrf_obj_default, "nbasis"), 1L)
  expect_equal(attr(hrf_obj_default, "span"), 24)
  expect_null(attr(hrf_obj_default, "param_names"))
  expect_equal(attr(hrf_obj_default, "params"), list())
  
  # Check multi-basis
  my_multi_func <- function(t) { cbind(t, t^2) }
  hrf_multi <- as_hrf(my_multi_func, nbasis = 2L)
  expect_equal(attr(hrf_multi, "nbasis"), 2L)
  expect_equal(as.matrix(hrf_multi(3)), as.matrix(cbind(3, 9)), check.attributes = FALSE)
})

test_that("bind_basis combines HRF objects correctly", {
  # Create individual HRF objects
  f1 <- function(t) { t }
  f2 <- function(t) { t^2 }
  f3 <- function(t) { rep(1, length(t)) }
  
  hrf1 <- as_hrf(f1, name="linear", span=10)
  hrf2 <- as_hrf(f2, name="quadratic", span=12)
  hrf3 <- as_hrf(f3, name="constant", span=8)
  
  # Combine them
  combined_hrf <- bind_basis(hrf1, hrf2, hrf3)
  
  # Check class
  expect_true(inherits(combined_hrf, "HRF"))
  expect_true(inherits(combined_hrf, "function"))
  
  # Check attributes
  expect_equal(attr(combined_hrf, "name"), "linear + quadratic + constant")
  expect_equal(attr(combined_hrf, "nbasis"), 3L) # 1 + 1 + 1
  expect_equal(attr(combined_hrf, "span"), 12) # max(10, 12, 8)
  
  # Check function evaluation
  t_vals <- c(0, 1, 2, 5)
  expected_output <- cbind(f1(t_vals), f2(t_vals), f3(t_vals))
  colnames(expected_output) <- NULL # Match the expected output of bind_basis function
  
  # Use check.attributes = FALSE for robustness against potential slight differences
  expect_equal(combined_hrf(t_vals), expected_output, check.attributes = FALSE)
  
  # Test with a multi-basis input
  f_multi <- function(t) cbind(sin(t), cos(t))
  hrf_multi <- as_hrf(f_multi, name="trig", nbasis=2L, span=15)
  
  combined_hrf2 <- bind_basis(hrf1, hrf_multi)
  expect_equal(attr(combined_hrf2, "nbasis"), 3L) # 1 + 2
  expect_equal(attr(combined_hrf2, "span"), 15) # max(10, 15)
  expect_equal(attr(combined_hrf2, "name"), "linear + trig")
  
  expected_output2 <- cbind(f1(t_vals), f_multi(t_vals))
  colnames(expected_output2) <- NULL
  expect_equal(combined_hrf2(t_vals), expected_output2, check.attributes = FALSE)
  
  # Test binding just one element
  combined_single <- bind_basis(hrf1)
  expect_equal(attr(combined_single, "name"), "linear")
  expect_equal(attr(combined_single, "nbasis"), 1L)
  expect_equal(attr(combined_single, "span"), 10)
  expect_equal(combined_single(t_vals), f1(t_vals))
})

test_that("lag_hrf correctly lags an HRF object", {
  # Use HRF_SPMG1 as the base HRF
  base_hrf <- HRF_SPMG1
  t <- seq(0, 30, by = 0.5)
  lag_amount <- 5
  
  # Create lagged HRF
  lagged_hrf <- lag_hrf(base_hrf, lag_amount)
  
  # Test basic structure
  expect_true(inherits(lagged_hrf, "HRF"))
  expect_true(inherits(lagged_hrf, "function"))
  expect_equal(nbasis(lagged_hrf), nbasis(base_hrf))
  expect_equal(attr(lagged_hrf, "span"), attr(base_hrf, "span") + lag_amount)
  expect_true(grepl(paste0("_lag\\(", lag_amount, "\\)"), attr(lagged_hrf, "name")))
  expect_equal(attr(lagged_hrf, "params")$.lag, lag_amount)

  # Test function evaluation: lagged_hrf(t) should equal base_hrf(t - lag)
  result_lagged <- lagged_hrf(t)
  result_manual_lag <- base_hrf(t - lag_amount)
  expect_equal(result_lagged, result_manual_lag)
  
  # Test peak timing (should be shifted by lag_amount)
  peak_lagged <- t[which.max(result_lagged)]
  peak_base <- t[which.max(base_hrf(t))]
  # Allow for slight tolerance due to discrete time steps
  expect_true(abs((peak_lagged - peak_base) - lag_amount) < 1) 
  
  # Test with zero lag
  lagged_zero <- lag_hrf(base_hrf, 0)
  expect_equal(lagged_zero(t), base_hrf(t))
  expect_equal(attr(lagged_zero, "span"), attr(base_hrf, "span"))
  
  # Test with a multi-basis HRF (HRF_SPMG2)
  base_hrf_multi <- HRF_SPMG2
  lagged_hrf_multi <- lag_hrf(base_hrf_multi, lag_amount)
  expect_equal(nbasis(lagged_hrf_multi), nbasis(base_hrf_multi))
  expect_equal(lagged_hrf_multi(t), base_hrf_multi(t - lag_amount))
  expect_equal(attr(lagged_hrf_multi, "span"), attr(base_hrf_multi, "span") + lag_amount)
})

test_that("block_hrf correctly blocks an HRF object", {
  base_hrf <- HRF_SPMG1
  t <- seq(0, 30, by = 0.2)
  width <- 5
  precision <- 0.2
  half_life_inf <- 1e12

  blocked_hrf_sum <- block_hrf(base_hrf, width = width, precision = precision, half_life = half_life_inf, summate = TRUE, normalize = FALSE)
  blocked_hrf_max <- block_hrf(base_hrf, width = width, precision = precision, half_life = half_life_inf, summate = FALSE, normalize = FALSE)
  blocked_hrf_norm <- block_hrf(base_hrf, width = width, precision = precision, half_life = half_life_inf, summate = TRUE, normalize = TRUE)

  # Test basic structure
  expect_true(inherits(blocked_hrf_sum, "HRF"))
  expect_equal(nbasis(blocked_hrf_sum), nbasis(base_hrf))
  expect_equal(attr(blocked_hrf_sum, "span"), attr(base_hrf, "span") + width)
  expect_true(grepl(paste0("_block\\(w=", width, "\\)"), attr(blocked_hrf_sum, "name")))
  expect_equal(attr(blocked_hrf_sum, "params")$.width, width)
  expect_equal(attr(blocked_hrf_sum, "params")$.summate, TRUE)
  expect_equal(attr(blocked_hrf_max, "params")$.summate, FALSE)
  expect_equal(attr(blocked_hrf_norm, "params")$.normalize, TRUE)

  # Test function evaluation - Compare with evaluate.HRF which uses similar logic
  eval_res_sum <- evaluate(base_hrf, t, duration = width, precision = precision, summate = TRUE, normalize = FALSE)
  eval_res_max <- evaluate(base_hrf, t, duration = width, precision = precision, summate = FALSE, normalize = FALSE)
  eval_res_norm <- evaluate(base_hrf, t, duration = width, precision = precision, summate = TRUE, normalize = TRUE)

  expect_equal(blocked_hrf_sum(t), eval_res_sum)
  # Max logic might differ slightly depending on implementation details, check if shape is reasonable
  # expect_equal(blocked_hrf_max(t), eval_res_max)
  expect_false(identical(blocked_hrf_sum(t), blocked_hrf_max(t)))
  expect_equal(blocked_hrf_norm(t), eval_res_norm)
  expect_equal(max(abs(blocked_hrf_norm(t))), 1) # Check normalization worked

  # Test width_block > width_no_block (as in gen_hrf test)
  result_block <- blocked_hrf_sum(t)
  result_no_block <- base_hrf(t)
  
  # Compare Area Under Curve (AUC) approximation as a measure of width/magnitude
  auc_block <- sum(abs(result_block)) * (t[2]-t[1]) # Multiply by time step for approx integral
  auc_no_block <- sum(abs(result_no_block)) * (t[2]-t[1])
  
  expect_true(auc_block > auc_no_block)

  # Test half_life
  blocked_hl <- block_hrf(base_hrf, width = width, precision = precision, half_life = 2)
  expect_false(identical(blocked_hl(t), blocked_hrf_sum(t)))
  expect_true(max(abs(blocked_hl(t))) < max(abs(blocked_hrf_sum(t)))) # Expect decay to reduce peak

  # Test negligible width
  blocked_negligible <- block_hrf(base_hrf, width = 0.01, precision = 0.1, half_life = half_life_inf)
  expect_equal(blocked_negligible(t), base_hrf(t))
})

test_that("normalise_hrf correctly normalises an HRF object", {
  # Create an unnormalised HRF (Gaussian scaled by 5)
  unnorm_func <- function(t) 5 * dnorm(t, 6, 2)
  unnorm_hrf <- as_hrf(unnorm_func, name="unnorm_gauss")
  t <- seq(0, 20, by=0.1)
  
  # Normalise it
  norm_hrf <- normalise_hrf(unnorm_hrf)

  # Test basic structure
  expect_true(inherits(norm_hrf, "HRF"))
  expect_equal(nbasis(norm_hrf), 1)
  expect_equal(attr(norm_hrf, "span"), attr(unnorm_hrf, "span"))
  expect_true(grepl("_norm", attr(norm_hrf, "name")))
  expect_equal(attr(norm_hrf, "params")$.normalised, TRUE)
  
  # Test peak value
  result_norm <- norm_hrf(t)
  expect_equal(max(abs(result_norm)), 1)
  
  # Test relationship to original
  result_unnorm <- unnorm_hrf(t)
  peak_unnorm <- max(abs(result_unnorm))
  expect_equal(result_norm, result_unnorm / peak_unnorm)
  
  # Test with an already normalised HRF (should remain normalised)
  norm_spmg1 <- normalise_hrf(HRF_SPMG1)
  expect_equal(max(abs(norm_spmg1(t))), 1, tolerance = 1e-7)
  
  # Test with multi-basis HRF (HRF_SPMG2)
  unnorm_spmg2_func <- function(t) cbind(5 * HRF_SPMG2(t)[,1], 10 * HRF_SPMG2(t)[,2])
  unnorm_spmg2 <- as_hrf(unnorm_spmg2_func, name="unnorm_spmg2", nbasis=2L)
  norm_spmg2 <- normalise_hrf(unnorm_spmg2)
  
  expect_equal(nbasis(norm_spmg2), 2)
  result_norm_spmg2 <- norm_spmg2(t)
  expect_equal(max(abs(result_norm_spmg2[,1])), 1)
  expect_equal(max(abs(result_norm_spmg2[,2])), 1)
})

test_that("normalised multi-basis HRF evaluated at single point returns matrix", {
  norm_spmg2 <- normalise_hrf(HRF_SPMG2)
  single_res <- norm_spmg2(0)
  expect_true(is.matrix(single_res))
  expect_equal(dim(single_res), c(1, nbasis(norm_spmg2)))
})

test_that("gen_hrf correctly sets nbasis for function inputs", {
  # Single basis functions
  hrf_g <- gen_hrf(hrf_gaussian)
  expect_equal(nbasis(hrf_g), 1)
  
  hrf_s1 <- gen_hrf(hrf_spmg1)
  expect_equal(nbasis(hrf_s1), 1)
  
  # Single basis HRF object
  hrf_s1_obj <- gen_hrf(HRF_SPMG1)
  expect_equal(nbasis(hrf_s1_obj), 1)

  # Multi-basis HRF objects
  hrf_s2_obj <- gen_hrf(HRF_SPMG2)
  expect_equal(nbasis(hrf_s2_obj), 2)
  
  hrf_s3_obj <- gen_hrf(HRF_SPMG3)
  expect_equal(nbasis(hrf_s3_obj), 3)

  # Function with parameters determining nbasis
  hrf_bs5 <- gen_hrf(hrf_bspline, N = 5)
  expect_equal(nbasis(hrf_bs5), 5)
  
  hrf_bs4 <- gen_hrf(hrf_bspline, N = 4)
  expect_equal(nbasis(hrf_bs4), 4)
  
  # Tent function (bspline with degree 1)
  hrf_tent7 <- gen_hrf(hrf_bspline, N = 7, degree = 1)
  expect_equal(nbasis(hrf_tent7), 7)
})

test_that("normalize in evaluate.HRF preserves matrix dimensions", {
  grid <- seq(0, 2, by = 1)
  res <- evaluate(HRF_SPMG2, grid, normalize = TRUE)
  expect_true(is.matrix(res))
  expect_equal(dim(res), c(length(grid), nbasis(HRF_SPMG2)))

  single <- evaluate(HRF_SPMG2, 0, normalize = TRUE)
  expect_true(is.matrix(single))
  expect_equal(dim(single), c(1L, nbasis(HRF_SPMG2)))
})

test_that("lag_hrf and block_hrf enforce finite parameters", {
  expect_error(lag_hrf(HRF_SPMG1, Inf), "finite")
  expect_error(lag_hrf(HRF_SPMG1, NA_real_), "finite")
  expect_error(block_hrf(HRF_SPMG1, width = Inf, precision = 0.1, half_life = 1), "finite")
  expect_error(block_hrf(HRF_SPMG1, width = 1, precision = Inf, half_life = 1), "finite")
  # half_life = Inf is now allowed (means no decay)
  expect_no_error(block_hrf(HRF_SPMG1, width = 1, precision = 0.1, half_life = Inf))
})

test_that("evaluate.HRF validates grid and precision", {
  expect_error(evaluate(HRF_SPMG1, numeric(0)), "grid")
  expect_error(evaluate(HRF_SPMG1, c(0, NA)), "grid")
  expect_error(evaluate(HRF_SPMG1, 0:1, precision = 0), "precision")
  expect_error(evaluate(HRF_SPMG1, 0:1, precision = -0.5), "precision")

})
</file>

<file path="tests/testthat/test_regressor.R">
context("Reg and regressor")

library(testthat)

# Helper HRF that returns 1 for t in [0,1] and 0 otherwise
box_hrf_fun <- function(t) {
  ifelse(t >= 0 & t <= 1, 1, 0)
}
BOX_HRF <- as_hrf(box_hrf_fun, name = "box", span = 1)


test_that("regressor constructs valid Reg objects", {
  reg <- regressor(onsets = c(0, 10, 20),
                   hrf = HRF_GAMMA,
                   duration = 2,
                   amplitude = c(1, 2, 3),
                   span = 30)

  expect_s3_class(reg, "Reg")
  expect_true(inherits(reg, "list"))
  expect_equal(reg$onsets, c(0, 10, 20))
  expect_equal(reg$duration, rep(2, 3))
  expect_equal(reg$amplitude, c(1, 2, 3))
  expect_identical(reg$hrf, HRF_GAMMA)
  # span should take from HRF when provided
  expect_equal(reg$span, attr(HRF_GAMMA, "span"))
  expect_false(attr(reg, "filtered_all"))
})


test_that("events with zero amplitude are filtered", {
  reg <- regressor(onsets = c(1, 2, 3), amplitude = c(1, 0, 2))
  expect_equal(reg$onsets, c(1, 3))
  expect_equal(reg$duration, c(0, 0))
  expect_equal(reg$amplitude, c(1, 2))
  expect_false(attr(reg, "filtered_all"))

  reg_empty <- regressor(onsets = c(1, 2), amplitude = c(0, 0))
  expect_length(reg_empty$onsets, 0)
  expect_true(attr(reg_empty, "filtered_all"))
})

test_that("NA inputs trigger errors", {
  # Single NA onset is treated as empty regressor (special case)
  expect_no_error(regressor(onsets = NA_real_))
  expect_error(regressor(onsets = c(1, NA)), "onsets")
  expect_error(regressor(onsets = 1, duration = NA_real_), "duration")
  expect_error(regressor(onsets = 1, amplitude = NA_real_), "amplitude")
  expect_error(regressor(onsets = 1, span = NA_real_), "span")
})


test_that("invalid inputs are rejected", {
  expect_error(regressor(onsets = c(-1, 1)), "onsets")
  expect_error(regressor(onsets = 1, duration = -2), "duration")
  expect_error(regressor(onsets = 1, span = 0), "span")
  expect_error(regressor(onsets = c(1, Inf)), "onsets")
  expect_error(regressor(onsets = 1, duration = Inf), "duration")
  expect_error(regressor(onsets = 1, amplitude = Inf), "amplitude")
  expect_error(regressor(onsets = 1, span = Inf), "span")
})


test_that("single_trial_regressor returns a length-1 Reg", {
  st <- single_trial_regressor(onsets = 5, duration = 2, amplitude = 3)
  expect_s3_class(st, "Reg")
  expect_equal(length(st$onsets), 1)
  expect_equal(st$onsets, 5)
  expect_equal(st$duration, 2)
  expect_equal(st$amplitude, 3)
})


test_that("shift.Reg shifts onsets correctly", {
  reg <- regressor(c(0, 2), hrf = HRF_SPMG1)
  shifted <- shift(reg, 5)
  expect_equal(shifted$onsets, c(5, 7))
  expect_identical(shifted$duration, reg$duration)
  expect_identical(shifted$amplitude, reg$amplitude)
})

test_that("shift.Reg accepts offset argument", {
  reg <- regressor(c(1, 3), hrf = HRF_SPMG1)
  shifted <- shift(reg, offset = 2)
  expect_equal(shifted$onsets, c(3, 5))
})

test_that("shift.Reg errors without shift specification", {
  reg <- regressor(0, hrf = HRF_SPMG1)
  expect_error(shift(reg), "shift_amount")
})


test_that("evaluate.Reg computes convolution correctly", {
  reg <- regressor(onsets = c(0, 2), hrf = BOX_HRF, span = 1)
  grid <- 0:4
  result <- evaluate(reg, grid, method = "conv", precision = 1)
  expect_equal(result, c(1, 1, 1, 1, 0))
})


test_that("Rconv handles non-zero constant durations", {
  reg <- regressor(onsets = c(0, 2), duration = 2, amplitude = c(1, 1),
                   hrf = BOX_HRF, span = 1)
  grid <- 0:6
  res_conv <- evaluate(reg, grid, method = "conv", precision = 1)
  res_rconv <- evaluate(reg, grid, method = "Rconv", precision = 1)
  expect_equal(res_rconv, res_conv)
})


test_that("unsorted grid triggers warning and sorted output", {
  reg <- regressor(onsets = 0, hrf = BOX_HRF, span = 1)
  expect_warning(out <- evaluate(reg, c(3, 0, 1), method = "conv", precision = 1))
  expect_equal(out, evaluate(reg, sort(c(3, 0, 1)), method = "conv", precision = 1))
})


test_that("evaluate.Reg validates grid and precision", {
  reg <- regressor(onsets = 0, hrf = BOX_HRF, span = 1)
  expect_error(evaluate(reg, numeric(0), method = "conv"), "grid")
  expect_error(evaluate(reg, c(0, NA), method = "conv"), "grid")
  expect_error(evaluate(reg, 0:1, precision = 0, method = "conv"), "precision")
  expect_error(evaluate(reg, 0:1, precision = -1, method = "conv"), "precision")
})
</file>

<file path="R/evaluate-helpers.R">
#' @importFrom memoise memoise
#' @keywords internal
#' @noRd
.memo_hrf <- memoise::memoise(function(hrf, span, dt) {
    if (!is.numeric(span) || length(span) != 1 || span <= 0) {
        stop("`span` must be a single numeric value strictly greater than 0.", call. = FALSE)
    }
    if (!is.numeric(dt) || length(dt) != 1 || dt <= 0) {
        stop("`dt` must be a single numeric value strictly greater than 0.", call. = FALSE)
    }
    times <- seq(0, span, by = dt)
    # Evaluate HRF - ensure it returns a matrix
    val <- evaluate(hrf, times)
    if (is.vector(val)) matrix(val, ncol = 1) else val
})

#' Prepare Inputs for Regressor Evaluation Engines
#' 
#' Internal helper function to perform common setup steps before calling 
#' a specific evaluation engine (fft, conv, loop, Rconv).
#' Handles filtering of events, evaluation/memoization of HRF on fine grid.
#' 
#' @param x A `Reg` object.
#' @param grid The target evaluation time grid (numeric vector).
#' @param precision The precision for internal calculations (numeric scalar).
#' @return A list containing prepared inputs:
#'   * `nb`: Number of basis functions.
#'   * `hrf_span`: The span of the HRF.
#'   * `valid_ons`: Filtered onset times relevant to the grid.
#'   * `valid_durs`: Corresponding durations.
#'   * `valid_amp`: Corresponding amplitudes.
#'   * `grid`: The original target grid.
#'   * `precision`: The precision value.
#'   * `hrf_fine_matrix`: HRF values evaluated on the fine time grid (potentially memoized).
#'   * `fine_grid`: The fine time grid itself (if needed by Rconv/loop).
#'   * `summate`: Logical summation flag from the regressor.
#'   * `hrf`: The original HRF object.
#' @keywords internal
#' @noRd
#' @importFrom stats approx median convolve
prep_reg_inputs <- function(x, grid, precision) {
  
  # Ensure grid is sorted (Correctness 1.4)
  if (is.unsorted(grid)) {
      warning("Input grid is unsorted. Sorting grid for evaluation.")
      grid <- sort(grid)
  }
    
  nb <- nbasis(x$hrf) 
  hrf_span <- x$span 
  
  # Filter events based on grid boundaries and HRF span
  onset_min_bound <- grid[1] - hrf_span
  onset_max_bound <- grid[length(grid)]
  
  # Start with potentially already filtered data from Reg constructor
  keep_indices <- which(x$onsets >= onset_min_bound & x$onsets <= onset_max_bound)
  
  # Note: Amplitude filtering already done in Reg(), no need to repeat here
  valid_ons <- x$onsets[keep_indices]
  valid_durs <- x$duration[keep_indices]
  valid_amp <- x$amplitude[keep_indices]

  if (length(valid_ons) == 0) {
    # Return minimal info needed to signal zero output
    return(list(nb = nb, grid = grid, valid_ons = numeric(0)))
  }
  
  # Prepare/Memoize finely sampled HRF for efficient evaluation
  hrf_fine_matrix <- .memo_hrf(x$hrf, hrf_span, precision)
  
  # Prepare fine grid (needed for Rconv/loop interpolation)
  # Start at the earliest possible contribution from kept events
  # which occurs at `grid[1] - hrf_span`
  fine_grid_start <- grid[1] - hrf_span
  # Use the full range of onsets when determining the end of the fine grid
  # to handle unsorted event inputs without reordering
  fine_grid_end <- max(grid[length(grid)], max(valid_ons) + max(valid_durs)) + hrf_span
  fine_grid <- seq(fine_grid_start, fine_grid_end, by = precision)

  return(list(
    nb         = nb,
    hrf_span   = hrf_span,
    valid_ons  = valid_ons,
    valid_durs = valid_durs,
    valid_amp  = valid_amp,
    grid       = grid,
    precision  = precision,
    hrf_fine_matrix = hrf_fine_matrix,
    fine_grid  = fine_grid, 
    summate    = x$summate,
    hrf        = x$hrf
  ))
}

# Internal Evaluation Engines -----

#' FFT-based Regressor Evaluation Engine
#' @param p A list returned by prep_reg_inputs.
#' @param ... Additional arguments.
#' @keywords internal
#' @noRd
eval_fft <- function(p, ...) {
  # Call the unified C++ wrapper
  result <- evaluate_regressor_cpp(
              grid = p$grid,
              onsets = p$valid_ons,
              durations = p$valid_durs,
              amplitudes = p$valid_amp,
              hrf_matrix = p$hrf_fine_matrix,
              hrf_span = p$hrf_span,
              precision = p$precision,
              method = "fft"
            )
  result
}

#' Direct Convolution Regressor Evaluation Engine
#' @param p A list returned by prep_reg_inputs.
#' @param ... Additional arguments.
#' @keywords internal
#' @noRd
eval_conv <- function(p, ...) {
  # Call the unified C++ wrapper
  result <- evaluate_regressor_cpp(
              grid = p$grid,
              onsets = p$valid_ons,
              durations = p$valid_durs,
              amplitudes = p$valid_amp,
              hrf_matrix = p$hrf_fine_matrix,
              hrf_span = p$hrf_span,
              precision = p$precision,
              method = "conv"
            )
  result
}

#' R Convolution Regressor Evaluation Engine
#' @param p A list returned by prep_reg_inputs.
#' @param ... Additional arguments.
#' @keywords internal
#' @noRd
#' @importFrom stats convolve approx
eval_Rconv <- function(p, ...) {
  # Check conditions (moved from evaluate.Reg)
  is_regular_grid <- length(p$grid) > 1 && length(unique(round(diff(p$grid), 8))) == 1
  is_constant_duration <- length(unique(p$valid_durs)) <= 1
  
  if (!is_regular_grid || !is_constant_duration) {
    warning("Method 'Rconv' requires a regular grid and constant event durations. Falling back to 'loop' method.")
    return(eval_loop(p, ...)) # Call the loop engine directly as fallback
  }
  
  # Proceed with R convolution using stats::convolve
  delta <- numeric(length(p$fine_grid))
  onset_indices <- floor((p$valid_ons - p$fine_grid[1]) / p$precision) + 1
  valid_onset_indices <- onset_indices >= 1 & onset_indices <= length(p$fine_grid)

  if (length(p$valid_durs) > 0) {
    dur_len <- floor(p$valid_durs[1] / p$precision)
  } else {
    dur_len <- 0
  }

  for (i in which(valid_onset_indices)) {
    start_idx <- onset_indices[i]
    end_idx <- min(start_idx + dur_len, length(p$fine_grid))
    delta[start_idx:end_idx] <- delta[start_idx:end_idx] + p$valid_amp[i]
  }
  
  samhrf <- p$hrf_fine_matrix # Already evaluated and potentially memoized
  nb <- p$nb
  
  if (nb > 1) {
    lowres <- matrix(0, length(p$grid), nb)
    for (b in 1:nb) {
      highres_conv <- stats::convolve(delta, rev(samhrf[, b]), type = "open")
      valid_len <- length(p$fine_grid)
      highres_trimmed <- highres_conv[1:valid_len]
      interp_res <- approx(p$fine_grid, highres_trimmed, xout = p$grid, rule = 2)$y
      lowres[, b] <- interp_res
    }
    result <- lowres
  } else {
    highres_conv <- stats::convolve(delta, rev(as.vector(samhrf)), type = "open")
    valid_len <- length(p$fine_grid)
    highres_trimmed <- highres_conv[1:valid_len]
    result <- approx(p$fine_grid, highres_trimmed, xout = p$grid, rule = 2)$y
  }
  result
}

#' R Loop Regressor Evaluation Engine
#' @param p A list returned by prep_reg_inputs.
#' @param ... Additional arguments passed to evaluate.HRF.
#' @keywords internal
#' @noRd
eval_loop <- function(p, ...) {
  # Add check for p$hrf
  if (is.null(p$hrf) || !inherits(p$hrf, "HRF")) {
      stop("Error inside eval_loop: p$hrf is NULL or not an HRF object.")
  }
  
  nb <- p$nb
  hrf_span <- p$hrf_span
  grid <- p$grid
  valid_ons <- p$valid_ons
  valid_durs <- p$valid_durs
  valid_amp <- p$valid_amp
  precision <- p$precision
  summate <- p$summate
  
  dspan <- hrf_span / stats::median(diff(grid), na.rm=TRUE) # Approx span in grid units
  
  # Pre-calculate nearest grid indices for onsets (more robust than RANN for this)
  # Find the index of the grid point *just before or at* each onset
  nidx <- findInterval(valid_ons, grid)
  nidx[nidx == 0] <- 1 
  
  outmat <- matrix(0, length(grid), nb)

  for (i in seq_along(valid_ons)) { 
    start_grid_idx <- nidx[i]
    end_grid_idx <- min(start_grid_idx + ceiling(dspan) + 5, length(grid)) 
    if (start_grid_idx > length(grid)) next 
    grid.idx <- start_grid_idx:end_grid_idx
      
    relOns <- grid[grid.idx] - valid_ons[i]
    valid_rel_idx <- which(relOns >= 0 & relOns <= hrf_span)
      
    if (length(valid_rel_idx) > 0) {
        target_indices_outmat <- grid.idx[valid_rel_idx]
        # Call evaluate S3 generic, should dispatch to evaluate.HRF
        resp <- evaluate(p$hrf, relOns[valid_rel_idx], amplitude=valid_amp[i], 
                         duration=valid_durs[i], 
                         precision=precision,
                         summate=summate, ...)
                           
        if (!is.matrix(resp) && nb > 1) {
            resp <- matrix(resp, ncol=nb)
        }
        if (!is.matrix(resp) && nb == 1) {
            resp <- matrix(resp, ncol=1)
        }

        if (nrow(resp) != length(target_indices_outmat)){
            warning("Dimension mismatch between response and target indices in loop.")
            next
        }
                          
        outmat[target_indices_outmat, seq_len(nb)] <-
          outmat[target_indices_outmat, seq_len(nb), drop = FALSE] + resp
    }
  }
  
  outmat
}
</file>

<file path="R/hrf-formula.R">
#' Create an HRF from a basis specification
#'
#' `make_hrf` resolves a basis specification to an `HRF` object and
#' applies an optional temporal lag. The basis may be given as the name
#' of a built-in HRF, as a generating function, or as an existing `HRF`
#' object.
#'
#' @param basis Character name of a built-in HRF, a function that
#'   generates HRF values, or an object of class `HRF`.
#' @param lag Numeric scalar giving the shift in seconds applied to the
#'   HRF.
#' @param nbasis Integer specifying the number of basis functions when
#'   `basis` is provided as a name.
#'
#' @return An object of class `HRF` representing the lagged basis.
#'
#' @examples
#' # Canonical SPM HRF delayed by 2 seconds
#' h <- make_hrf("spmg1", lag = 2)
#' h(0:5)
#'
#' @export
make_hrf <- function(basis, lag, nbasis = 1) {
  if (!is.numeric(lag) || length(lag) != 1 || !is.finite(lag)) {
    stop("`lag` must be a single finite numeric value.")
  }
  if (!is.numeric(nbasis) || length(nbasis) != 1 || !is.finite(nbasis) ||
      nbasis < 1 || nbasis %% 1 != 0) {
    stop("`nbasis` must be a single positive integer.")
  }
  nbasis <- as.integer(nbasis)
  
  if (is.character(basis)) {

    # Resolve character name to a base HRF object or function using getHRF
    # Note: getHRF itself might need simplification later; it currently calls
    # gen_hrf internally for most types.
    base_hrf_obj <- getHRF(basis, nbasis=nbasis, lag=0)
    # Apply lag using gen_hrf
    final_hrf <- gen_hrf(base_hrf_obj, lag = lag)


  } else if (inherits(basis, "HRF")) {
    # If it's already an HRF object, apply lag using gen_hrf
    final_hrf <- gen_hrf(basis, lag = lag)
    
  } else if (is.function(basis)) {
    # If a plain function is provided, explicitly convert it to an HRF so that
    # the number of basis functions is set correctly before applying any
    # decorators.
    basis <- as_hrf(basis, nbasis = nbasis)
    final_hrf <- gen_hrf(basis, lag = lag)

  } else {
    stop(sprintf(
      "invalid basis function '%s' of class %s: must be 1) character string indicating hrf type, e.g. 'gamma', 2) a function or 3) an object of class 'HRF'",
      deparse(substitute(basis)), paste(class(basis), collapse = ", ")
    ))
  }
  
  return(final_hrf)
}
</file>

<file path="tests/testthat/test_sampling_frame.R">
context("Sampling Frame")

test_that("sampling_frame constructor works correctly", {
  # Basic construction
  sframe <- sampling_frame(blocklens = c(100, 100), TR = 2)
  expect_s3_class(sframe, "sampling_frame")
  expect_equal(length(sframe$blocklens), 2)
  expect_equal(sframe$TR, c(2, 2))
  expect_equal(sframe$start_time, c(1, 1))
  
  # Test with different TRs per block
  sframe2 <- sampling_frame(blocklens = c(100, 200), TR = c(2, 1.5))
  expect_equal(sframe2$TR, c(2, 1.5))
  
  # Test input validation
  expect_error(sampling_frame(blocklens = c(-1, 100), TR = 2),
              "Block lengths must be positive")
  expect_error(sampling_frame(blocklens = c(100, 100), TR = -1),
              "TR .* must be positive")
  expect_error(sampling_frame(blocklens = c(100, 100), TR = 2, precision = 3),
              "Precision must be positive and less than")

  expect_error(sampling_frame(blocklens = c("a", 100), TR = 2),
               "numeric")
  expect_error(sampling_frame(blocklens = c(100, NA), TR = 2),
               "non-NA")
  expect_error(sampling_frame(blocklens = c(100, 100), TR = c(2, NA)),
               "non-NA")
  expect_error(sampling_frame(blocklens = c(100, 100), TR = "a"),
               "numeric")
  expect_error(sampling_frame(blocklens = c(100, 100), TR = 2,
                              start_time = c(0, NA)),
               "non-NA")

  expect_error(sampling_frame(blocklens = c(100, 100), TR = c(2, 2, 2)),
              "TR must have length 1 or match the number of blocks")
  expect_error(sampling_frame(blocklens = c(100, 100), TR = 2, start_time = c(0, 0, 0)),
              "start_time must have length 1 or match the number of blocks")

})

test_that("samples.sampling_frame works correctly", {
  sframe <- sampling_frame(blocklens = c(100, 100), TR = 2)
  
  # Test relative timing
  rel_samples <- samples(sframe, global = FALSE)
  expect_equal(length(rel_samples), 200)
  expect_equal(rel_samples[1:5], c(1, 3, 5, 7, 9))
  
  # Test global timing
  glob_samples <- samples(sframe, global = TRUE)
  expect_equal(length(glob_samples), 200)
  expect_equal(glob_samples[101] - glob_samples[100], 2)  # Check TR spacing
  
  # Test block selection
  block1_samples <- samples(sframe, blockids = 1)
  expect_equal(length(block1_samples), 100)
  
  # Test memoization
  samples2 <- samples(sframe, global = FALSE)
  expect_identical(rel_samples, samples2)  # Should return cached result
})

test_that("global_onsets works correctly", {
  sframe <- sampling_frame(blocklens = c(100, 100), TR = 2)
  
  # Test basic functionality
  onsets <- c(10, 20)
  blockids <- c(1, 2)
  global_times <- global_onsets(sframe, onsets, blockids)
  expect_equal(length(global_times), 2)
  expect_equal(global_times[1], 10)  # First block onset unchanged
  expect_equal(global_times[2], 220)  # Second block onset = 200 (block1 duration) + 20
  
  # Test error conditions for non-integer block ids
  expect_error(global_onsets(sframe, onsets, c(1.5, 2)),
               "blockids must be whole numbers")
  expect_error(global_onsets(sframe, onsets, c(1, NA)),
               "blockids must be whole numbers")
})

test_that("print.sampling_frame works correctly", {
  sframe <- sampling_frame(blocklens = c(100, 100), TR = 2)
  expect_output(print(sframe), "Sampling Frame")
  expect_output(print(sframe), "Structure")
  expect_output(print(sframe), "Timing")
  expect_output(print(sframe), "Duration")
})

test_that("sampling_frame handles edge cases", {
  # Single block
  single_block <- sampling_frame(blocklens = 100, TR = 2)
  expect_equal(length(single_block$blocklens), 1)
  expect_equal(length(samples(single_block)), 100)
  
  # Very short block
  short_block <- sampling_frame(blocklens = c(1, 1), TR = 2)
  expect_equal(length(samples(short_block)), 2)
  
  # Different start times
  custom_starts <- sampling_frame(blocklens = c(100, 100), 
                                TR = 2, 
                                start_time = c(0, 5))
  expect_equal(custom_starts$start_time, c(0, 5))
  
  # High precision
  high_prec <- sampling_frame(blocklens = c(10, 10), 
                            TR = 2, 
                            precision = 0.01)
  expect_equal(high_prec$precision, 0.01)
})

test_that("sampling_frame maintains temporal consistency", {
  sframe <- sampling_frame(blocklens = c(100, 100, 100), TR = 2)
  glob_samples <- samples(sframe, global = TRUE)
  
  # Check uniform spacing within blocks
  for (block in 1:3) {
    block_idx <- which(blockids(sframe) == block)
    diffs <- diff(glob_samples[block_idx])
    expect_true(all(abs(diffs - 2) < 1e-10))
  }
  
  # Check block transitions
  block_ends <- cumsum(sframe$blocklens)
  for (i in 1:(length(block_ends)-1)) {
    time_diff <- glob_samples[block_ends[i] + 1] - glob_samples[block_ends[i]]
    expect_equal(time_diff, 2)
  }
})

test_that("samples with blockids parameter works correctly for local and global timing", {
  sframe <- sampling_frame(blocklens = c(10, 10, 10), TR = 2)
  
  # Test 1: Verify blockids filtering for local timing
  block1_local <- samples(sframe, blockids = 1, global = FALSE)
  block2_local <- samples(sframe, blockids = 2, global = FALSE)
  block3_local <- samples(sframe, blockids = 3, global = FALSE)
  
  expect_equal(length(block1_local), 10)
  expect_equal(length(block2_local), 10)
  expect_equal(length(block3_local), 10)
  
  # All blocks should have same local timing pattern
  expect_equal(block1_local, block2_local)
  expect_equal(block2_local, block3_local)
  
  # Test 2: Verify blockids filtering for global timing
  block1_global <- samples(sframe, blockids = 1, global = TRUE)
  block2_global <- samples(sframe, blockids = 2, global = TRUE)
  block3_global <- samples(sframe, blockids = 3, global = TRUE)
  
  expect_equal(length(block1_global), 10)
  expect_equal(length(block2_global), 10)
  expect_equal(length(block3_global), 10)
  
  # Verify correct global offsets
  expect_equal(block1_global[1], 1)      # First sample of block 1
  expect_equal(block2_global[1], 21)     # First sample of block 2 (after 10*2=20s)
  expect_equal(block3_global[1], 41)     # First sample of block 3 (after 20*2=40s)
  
  # Test 3: Multiple blocks selection
  blocks12_global <- samples(sframe, blockids = c(1, 2), global = TRUE)
  expect_equal(length(blocks12_global), 20)
  expect_equal(blocks12_global[1:10], block1_global)
  expect_equal(blocks12_global[11:20], block2_global)
  
  # Test 4: Non-sequential block selection
  blocks13_global <- samples(sframe, blockids = c(1, 3), global = TRUE)
  expect_equal(length(blocks13_global), 20)
  expect_equal(blocks13_global[1:10], block1_global)
  expect_equal(blocks13_global[11:20], block3_global)
  
  # Test 5: Ensure it does NOT return all samples when specific blocks requested
  all_samples <- samples(sframe, global = TRUE)
  expect_equal(length(all_samples), 30)
  expect_true(length(block1_global) < length(all_samples))
})

test_that("samples with varying TR and start_time per block work correctly", {
  # Different TR per block
  sframe_varTR <- sampling_frame(
    blocklens = c(10, 10, 10), 
    TR = c(2, 1.5, 3),
    start_time = c(1, 0.75, 1.5)
  )
  
  # Test local timing respects per-block TR
  block1_local <- samples(sframe_varTR, blockids = 1, global = FALSE)
  block2_local <- samples(sframe_varTR, blockids = 2, global = FALSE)
  block3_local <- samples(sframe_varTR, blockids = 3, global = FALSE)
  
  # Check spacing
  expect_equal(diff(block1_local)[1], 2)    # TR = 2
  expect_equal(diff(block2_local)[1], 1.5)  # TR = 1.5
  expect_equal(diff(block3_local)[1], 3)    # TR = 3
  
  # Check start times
  expect_equal(block1_local[1], 1)      # start_time = 1
  expect_equal(block2_local[1], 0.75)   # start_time = 0.75
  expect_equal(block3_local[1], 1.5)    # start_time = 1.5
  
  # Test global timing
  block1_global <- samples(sframe_varTR, blockids = 1, global = TRUE)
  block2_global <- samples(sframe_varTR, blockids = 2, global = TRUE)
  block3_global <- samples(sframe_varTR, blockids = 3, global = TRUE)
  
  # Block 1: starts at 0 + 1 = 1
  expect_equal(block1_global[1], 1)
  
  # Block 2: starts at 20 (10*2) + 0.75 = 20.75
  expect_equal(block2_global[1], 20.75)
  
  # Block 3: starts at 20 + 15 (10*1.5) + 1.5 = 36.5
  expect_equal(block3_global[1], 36.5)
})

test_that("edge cases for blockids parameter", {
  sframe <- sampling_frame(blocklens = c(5, 10, 15), TR = 1)
  
  # Empty blockids
  expect_equal(length(samples(sframe, blockids = integer(0))), 0)
  
  # Out of order blockids
  out_order <- samples(sframe, blockids = c(3, 1, 2), global = TRUE)
  expect_equal(length(out_order), 30)
  
  # Repeated blockids
  repeated <- samples(sframe, blockids = c(1, 1), global = TRUE)
  expect_equal(length(repeated), 10)  # Block 1 appears twice, so 5*2 = 10
  
  # Single block from middle
  middle_block <- samples(sframe, blockids = 2, global = TRUE)
  expect_equal(length(middle_block), 10)
  expect_equal(middle_block[1], 5.5)  # After block 1 (5 scans * 1s TR) + start_time
})
</file>

<file path="R/all_generic.R">
#' Evaluate a regressor object over a time grid
#' 
#' Generic function to evaluate a regressor object over a specified time grid.
#' Different types of regressors may have different evaluation methods.
#'
#' @param x The regressor object to evaluate
#' @param grid A numeric vector specifying the time points at which to evaluate the regressor
#' @param ... Additional arguments passed to specific methods
#' @return A numeric vector or matrix containing the evaluated regressor values
#' @examples
#' # Create a regressor
#' reg <- regressor(onsets = c(10, 30, 50), hrf = HRF_SPMG1)
#' 
#' # Evaluate at specific time points
#' times <- seq(0, 80, by = 0.1)
#' response <- evaluate(reg, times)
#' 
#' # Plot the response
#' plot(times, response, type = "l", xlab = "Time (s)", ylab = "Response")
#' @seealso [single_trial_regressor()], [regressor()]
#' @export
evaluate <- function(x, grid, ...) {
  UseMethod("evaluate")
}



#' Shift a time series object
#'
#' @description
#' Apply a temporal shift to a time series object. This function shifts the values in time 
#' while preserving the structure of the object. Common uses include:
#' \describe{
#'   \item{alignment}{Aligning regressors with different temporal offsets}
#'   \item{derivatives}{Applying temporal derivatives to time series}
#'   \item{correction}{Correcting for timing differences between signals}
#' }
#'
#' @param x An object representing a time series or a time-based data structure
#' @param shift_amount Numeric; amount to shift by (positive = forward, negative = backward)
#' @param ... Additional arguments passed to methods
#' @return An object of the same class as the input, with values shifted in time:
#'   \describe{
#'     \item{Values}{Values are moved by the specified offset}
#'     \item{Structure}{Object structure and dimensions are preserved}
#'     \item{Padding}{Empty regions are filled with padding value}
#'   }
#' @examples
#' # Create a simple time series with events
#' event_data <- data.frame(
#'   onsets = c(1, 10, 20, 30),
#'   run = c(1, 1, 1, 1)
#' )
#' 
#' # Create regressor from events
#' reg <- regressor(
#'   onsets = event_data$onsets,
#'   hrf = HRF_SPMG1,
#'   duration = 0,
#'   amplitude = 1
#' )
#' 
#' # Shift regressor forward by 2 seconds
#' reg_forward <- shift(reg, shift_amount = 2)
#' 
#' # Shift regressor backward by 1 second
#' reg_backward <- shift(reg, shift_amount = -1)
#' 
#' # Evaluate original and shifted regressors
#' times <- seq(0, 50, by = 2)
#' orig_values <- evaluate(reg, times)
#' shifted_values <- evaluate(reg_forward, times)
#' @export
#' @family time_series
#' @seealso [regressor()], [evaluate()]
shift <- function(x, ...) {
  UseMethod("shift")
}



#' Combine HRF Basis with Coefficients
#'
#' Create a new HRF by linearly weighting the basis functions of an existing HRF.
#' Useful when coefficients have been estimated for an FIR/bspline/SPMG3 basis
#' and one wants a single functional HRF.
#'
#' @param hrf  An object of class `HRF`.
#' @param h    Numeric vector of length `nbasis(hrf)` giving the weights.
#' @param name Optional name for the resulting HRF.
#' @param ...  Reserved for future extensions.
#'
#' @return A new `HRF` object with `nbasis = 1`.
#' @examples
#' # Create a custom HRF from SPMG3 basis coefficients
#' coeffs <- c(1, 0.2, -0.1)  # Main response + slight temporal shift - dispersion
#' custom_hrf <- hrf_from_coefficients(HRF_SPMG3, coeffs)
#' 
#' # Evaluate the custom HRF
#' t <- seq(0, 20, by = 0.1)
#' response <- evaluate(custom_hrf, t)
#' 
#' # Create from FIR basis
#' fir_coeffs <- c(0, 0.2, 0.5, 1, 0.8, 0.4, 0.1, 0, 0, 0, 0, 0)
#' custom_fir <- hrf_from_coefficients(HRF_FIR, fir_coeffs)
#' @export
hrf_from_coefficients <- function(hrf, h, ...) UseMethod("hrf_from_coefficients")




#' Number of basis functions
#'
#' Return the number of basis functions represented by an object.
#'
#' This information is typically used when constructing penalty matrices
#' or understanding the complexity of an HRF model or regressor.
#'
#' @param x Object containing HRF or regressor information.
#' @param ... Additional arguments passed to methods.
#' @return Integer scalar giving the number of basis functions.
#' @examples
#' # Number of basis functions for different HRF types
#' nbasis(HRF_SPMG1)   # 1 basis function
#' nbasis(HRF_SPMG3)   # 3 basis functions (canonical + 2 derivatives)
#' nbasis(HRF_BSPLINE) # 5 basis functions (default)
#' 
#' # For a regressor
#' reg <- regressor(onsets = c(10, 30, 50), hrf = HRF_SPMG3)
#' nbasis(reg)  # 3 (inherits from the HRF)
#' @export
nbasis <- function(x, ...) UseMethod("nbasis")


#' Generate penalty matrix for regularization
#'
#' @description
#' Generate a penalty matrix for regularizing HRF basis coefficients. The penalty matrix
#' encodes shape priors that discourage implausible or overly wiggly HRF estimates.
#' Different HRF types use different penalty structures:
#' 
#' \itemize{
#'   \item{FIR/B-spline/Tent bases: Roughness penalties based on discrete derivatives}
#'   \item{SPM canonical + derivatives: Differential shrinkage of derivative terms}
#'   \item{Fourier bases: Penalties on high-frequency components}
#'   \item{Daguerre bases: Increasing weights on higher-order terms}
#'   \item{Default: Identity matrix (ridge penalty)}
#' }
#'
#' @param x The HRF object or basis specification
#' @param order Integer specifying the order of the penalty (default: 2)
#' @param ... Additional arguments passed to specific methods
#' @return A symmetric positive definite penalty matrix of dimension nbasis(x) × nbasis(x)
#' @details
#' The penalty matrix R is used in regularized estimation as λ * h^T R h, where h are
#' the basis coefficients and λ is the regularization parameter. Well-designed penalty
#' matrices can significantly improve HRF estimation by encoding smoothness or other
#' shape constraints.
#' 
#' @examples
#' # FIR basis with smoothness penalty
#' fir_hrf <- HRF_FIR
#' R_fir <- penalty_matrix(fir_hrf)
#' 
#' # B-spline basis with second-order smoothness
#' bspline_hrf <- HRF_BSPLINE  
#' R_bspline <- penalty_matrix(bspline_hrf, order = 2)
#' 
#' # SPM canonical with derivative shrinkage
#' spmg3_hrf <- HRF_SPMG3
#' R_spmg3 <- penalty_matrix(spmg3_hrf, shrink_deriv = 4)
#' 
#' @export
#' @family hrf
#' @seealso [nbasis()], [HRF_objects]
penalty_matrix <- function(x, ...) UseMethod("penalty_matrix")


#' Combine HRF Basis with Coefficients
#'
#' Create a new HRF by linearly weighting the basis functions of an existing HRF.
#' This is useful for turning estimated basis coefficients into a single
#' functional HRF.
#'


#' Reconstruction matrix for an HRF basis
#'
#' Returns a matrix \eqn{\Phi} that converts basis coefficients into a
#' sampled HRF shape.
#'
#' @param hrf An object of class `HRF`.
#' @param sframe A `sampling_frame` object or numeric vector of times.
#' @param ... Additional arguments passed to methods
#' @return A numeric matrix with one column per basis function.
#' @export
reconstruction_matrix <- function(hrf, sframe, ...) { UseMethod("reconstruction_matrix") }



#' Get durations of an object
#' 
#' @param x The object to get durations from
#' @param ... Additional arguments passed to methods
#' @return A numeric vector of durations
#' @export
durations <- function(x, ...) UseMethod("durations")

#' Get amplitudes from an object
#'
#' Generic accessor returning event amplitudes or scaling factors.
#'
#' @param x Object containing amplitude information
#' @param ... Additional arguments passed to methods
#' @return Numeric vector of amplitudes
#' @export
amplitudes <- function(x, ...) UseMethod("amplitudes")

#' Get event onsets from an object
#'
#' Generic accessor returning event onset times in seconds.
#'
#' @param x Object containing onset information
#' @param ... Additional arguments passed to methods
#' @return Numeric vector of onsets
#' @export
onsets <- function(x, ...) UseMethod("onsets")

#' Get sample acquisition times
#'
#' Generic function retrieving sampling times from a sampling frame or
#' related object.
#'
#' @param x Object describing the sampling grid
#' @param blockids Integer vector of block identifiers to include (default: all blocks)
#' @param global Logical indicating whether to return global times (default: FALSE)
#' @param ... Additional arguments passed to methods
#' @return Numeric vector of sample times
#' @export
samples <- function(x, ...) UseMethod("samples")

#' Convert onsets to global timing
#'
#' Generic accessor for converting block-wise onsets to global onsets.
#'
#' @param x Object describing the sampling frame
#' @param onsets Numeric vector of onset times within blocks
#' @param ... Additional arguments passed to methods
#' @return Numeric vector of global onset times
#' @export
global_onsets <- function(x, ...) UseMethod("global_onsets")

#' Get block identifiers
#'
#' Generic accessor returning block indices for each sample or onset.
#'
#' @param x Object containing block structure
#' @param ... Additional arguments passed to methods
#' @return Integer vector of block ids
#' @export
blockids <- function(x, ...) UseMethod("blockids")

#' Get block lengths
#'
#' Generic accessor returning the number of scans in each block of a
#' sampling frame or similar object.
#'
#' @param x Object containing block length information
#' @param ... Additional arguments passed to methods
#' @return Numeric vector of block lengths
#' @export
blocklens <- function(x, ...) UseMethod("blocklens")

#' Get fMRI Acquisition Onset Times
#'
#' Calculate the onset time in seconds for each fMRI volume acquisition
#' from the start of the experiment.
#'
#' @param x A sampling_frame object
#' @param ... Additional arguments (for extensibility)
#' @return Numeric vector of acquisition onset times in seconds
#' @details
#' Returns the temporal onset of each brain volume acquisition, accounting
#' for TR, start_time, and run structure. This is essentially a convenience
#' wrapper around \code{samples(x, global = TRUE)} that provides clearer
#' semantic meaning for the common use case of getting acquisition times.
#' 
#' Note: The onset times include the start_time offset (default TR/2),
#' so the first acquisition typically doesn't start at 0.
#' 
#' @seealso \code{\link{samples}} for more flexible timing queries
#' @export
#' @examples
#' # Single block with default start_time (TR/2 = 1)
#' sf <- sampling_frame(blocklens = 100, TR = 2)
#' onsets <- acquisition_onsets(sf)
#' head(onsets)  # Returns: 1, 3, 5, 7, 9, 11, ...
#' 
#' # Multiple blocks with same TR
#' sf2 <- sampling_frame(blocklens = c(100, 120), TR = 2)
#' onsets2 <- acquisition_onsets(sf2)
#' # First block: 1, 3, 5, ..., 199
#' # Second block: 201, 203, 205, ..., 439
#' 
#' # Variable TR per block
#' sf3 <- sampling_frame(blocklens = c(100, 100), TR = c(2, 1.5))
#' onsets3 <- acquisition_onsets(sf3)
#' # First block: 1, 3, 5, ..., 199 (TR=2)
#' # Second block: 200.75, 202.25, 203.75, ... (TR=1.5, start_time=0.75)
#' 
#' # Custom start times
#' sf4 <- sampling_frame(blocklens = c(50, 50), TR = 2, start_time = 0)
#' onsets4 <- acquisition_onsets(sf4)
#' head(onsets4)  # Returns: 0, 2, 4, 6, 8, 10, ...
acquisition_onsets <- function(x, ...) UseMethod("acquisition_onsets")






#' Generate Neural Input Function from Event Timing
#'
#' Converts event timing information into a neural input function representing the underlying
#' neural activity before HRF convolution. This function is useful for:
#' 
#' \describe{
#'   \item{stimulus}{Creating stimulus functions for fMRI analysis}
#'   \item{modeling}{Modeling sustained vs. transient neural activity}
#'   \item{inputs}{Generating inputs for HRF convolution}
#'   \item{visualization}{Visualizing the temporal structure of experimental designs}
#' }
#'
#' @param x A regressor object containing event timing information
#' @param start Numeric; start time of the input function
#' @param end Numeric; end time of the input function
#' @param resolution Numeric; temporal resolution in seconds (default: 0.33)
#' @param ... Additional arguments passed to methods
#'
#' @return A list containing:
#' \describe{
#'     \item{time}{Numeric vector of time points}
#'     \item{neural_input}{Numeric vector of input amplitudes at each time point}
#' }
#'
#' @examples
#' # Create a regressor with multiple events
#' reg <- regressor(
#'   onsets = c(10, 30, 50),
#'   duration = c(2, 2, 2),
#'   amplitude = c(1, 1.5, 0.8),
#'   hrf = HRF_SPMG1
#' )
#' 
#' # Generate neural input function
#' input <- neural_input(reg, start = 0, end = 60, resolution = 0.5)
#' 
#' # Plot the neural input function
#' plot(input$time, input$neural_input, type = "l",
#'      xlab = "Time (s)", ylab = "Neural Input",
#'      main = "Neural Input Function")
#' 
#' # Create regressor with varying durations
#' reg_sustained <- regressor(
#'   onsets = c(10, 30),
#'   duration = c(5, 10),  # sustained activity
#'   amplitude = c(1, 1),
#'   hrf = HRF_SPMG1
#' )
#' 
#' # Generate and compare neural inputs
#' input_sustained <- neural_input(
#'   reg_sustained,
#'   start = 0,
#'   end = 60,
#'   resolution = 0.5
#' )
#'
#' @family regressor_functions
#' @seealso 
#' \code{\link{regressor}}, \code{\link{evaluate.Reg}}, \code{\link{HRF_SPMG1}}
#' @export
neural_input <- function(x, ...) UseMethod("neural_input")
</file>

<file path="R/reg-constructor.R">
#' Internal Constructor for Regressor Objects
#' 
#' @keywords internal
#' @return An S3 object of class `Reg` (and `list`) with components:
#'   * `onsets`: Numeric vector of event onset times (seconds).
#'   * `hrf`: An object of class `HRF` used for convolution.
#'   * `duration`: Numeric vector of event durations (seconds).
#'   * `amplitude`: Numeric vector of event amplitudes/scaling factors.
#'   * `span`: Numeric scalar indicating the HRF span (seconds).
#'   * `summate`: Logical indicating if overlapping HRF responses should summate.
#'   * `filtered_all`: Logical attribute set to `TRUE` when all events were
#'     removed due to zero or `NA` amplitudes.
#' @importFrom assertthat assert_that
Reg <- function(onsets, hrf=HRF_SPMG1, duration=0, amplitude=1, span=40, summate=TRUE) {
  
  # Initial conversions
  onsets    <- as.numeric(onsets)
  duration  <- as.numeric(duration)
  amplitude <- as.numeric(amplitude)
  assert_that(is.logical(summate), length(summate) == 1)
  summate   <- as.logical(summate)
  span_arg  <- as.numeric(span) # Store original arg

  # Handle NA onset case explicitly (represents intent for zero events)
  if (length(onsets) == 1 && is.na(onsets[1])) {
      onsets <- numeric(0)
  }

  # Validate converted inputs for finiteness/NA
  if (anyNA(onsets) || any(!is.finite(onsets))) {
      stop("`onsets` must contain finite numeric values.", call. = FALSE)
  }
  if (anyNA(duration) || any(!is.finite(duration))) {
      stop("`duration` must contain finite numeric values.", call. = FALSE)
  }
  if (anyNA(amplitude) || any(!is.finite(amplitude))) {
      stop("`amplitude` must contain finite numeric values.", call. = FALSE)
  }
  if (is.na(span_arg) || !is.finite(span_arg) || span_arg <= 0) {
      stop("`span` must be a positive, finite number.", call. = FALSE)
  }
  n_onsets <- length(onsets)

  # Check for invalid onsets *before* recycling other args
  if (any(onsets < 0)) {
      stop("`onsets` must be non-negative.", call. = FALSE)
  }
  
  # Recycle/Validate inputs *before* filtering
  # Use recycle_or_error from utils-internal.R
  duration  <- recycle_or_error(duration, n_onsets, "duration")
  amplitude <- recycle_or_error(amplitude, n_onsets, "amplitude")
  
  # Check for invalid inputs early
  if (any(duration < 0, na.rm = TRUE)) stop("`duration` cannot be negative.")
  

  # Filter events based on non-zero and non-NA amplitude
  if (n_onsets > 0) { 
      keep_indices <- which(amplitude != 0 & !is.na(amplitude))
      # Store whether filtering occurred
      filtered_some <- length(keep_indices) < n_onsets
      # Store whether *all* were filtered
      filtered_all <- length(keep_indices) == 0
      
      if (filtered_some) {
          onsets    <- onsets[keep_indices]
          duration  <- duration[keep_indices]
          amplitude <- amplitude[keep_indices]
          n_onsets  <- length(onsets) # Update count after filtering
      }
  } else {
      filtered_all <- TRUE # If input was empty, effectively all are filtered
  }
  
  # Ensure HRF is a valid HRF object using make_hrf
  hrf  <- make_hrf(hrf, lag = 0) 
  assert_that(inherits(hrf, "HRF"), msg = "Invalid 'hrf' provided or generated.")
  
  # Determine final span using %||% helper (ensure helper is available)
  final_span <- attr(hrf, "span") %||% span_arg
  # Optional: Adjust span based on max duration? (kept from old regressor, review)
  # if (n_onsets > 0 && any(duration > final_span / 2)) {
  #    final_span <- max(duration, na.rm=TRUE) * 2
  # }

  # Construct the final object
  out <- structure(list(
    onsets      = onsets,
    duration    = duration,
    amplitude   = amplitude,
    hrf         = hrf,
    span        = final_span,
    summate     = summate
  ), class = c("Reg", "list"))
  
  # Add attribute to signal if all events were filtered
  attr(out, "filtered_all") <- filtered_all 
  return(out)
}


#' Construct a Regressor Object
#' 
#' Creates an object representing event-related regressors for fMRI modeling.
#' This function defines event onsets and associates them with a hemodynamic 
#' response function (HRF) to generate predicted time courses.
#' 
#' @param onsets A numeric vector of event onset times in seconds.
#' @param hrf The hemodynamic response function (HRF) to convolve with the events.
#'   This can be a pre-defined `HRF` object (e.g., `HRF_SPMG1`), a custom `HRF` 
#'   object created with `as_hrf`, a function `f(t)`, or a character string 
#'   referring to a known HRF type (e.g., "spmg1", "gaussian"). Defaults to `HRF_SPMG1`.
#' @param duration A numeric scalar or vector specifying the duration of each event 
#'   in seconds. If scalar, it's applied to all events. Defaults to 0 (impulse events).
#' @param amplitude A numeric scalar or vector specifying the amplitude (scaling factor) 
#'   for each event. If scalar, it's applied to all events. Defaults to 1.
#' @param span The temporal window (in seconds) over which the HRF is defined 
#'   or evaluated. This influences the length of the convolution. If not provided, 
#'   it may be inferred from the `hrf` object or default to 40s. **Note:** Unlike some
#'   previous versions, the `span` is not automatically adjusted based on `duration`;
#'   ensure the provided or inferred `span` is sufficient for your longest event duration.
#' @param summate Logical scalar; if `TRUE` (default), the HRF response amplitude scales
#'   with the duration of sustained events (via internal convolution/summation). If `FALSE`,
#'   the response reflects the peak HRF reached during the event duration.
#'   
#' @details 
#' This function serves as the main public interface for creating regressor objects. 
#' Internally, it utilizes the `Reg()` constructor which performs validation and 
#' efficient storage. The resulting object can be evaluated at specific time points 
#' using the `evaluate()` function.
#' 
#' Events with an amplitude of 0 are automatically filtered out.
#' 
#' @return An S3 object of class `Reg` and `list`
#'   containing processed event information and the HRF specification. The
#'   object includes a `filtered_all` attribute indicating whether all events
#'   were removed due to zero or `NA` amplitudes.
#' @examples
#' # Create a simple regressor with 3 events
#' reg <- regressor(onsets = c(10, 30, 50), hrf = HRF_SPMG1)
#' 
#' # Regressor with durations and amplitudes
#' reg2 <- regressor(
#'   onsets = c(10, 30, 50),
#'   duration = c(2, 2, 2),
#'   amplitude = c(1, 1.5, 0.8),
#'   hrf = HRF_SPMG1
#' )
#' 
#' # Using different HRF types
#' reg_gamma <- regressor(onsets = c(10, 30), hrf = "gamma")
#' 
#' # Evaluate regressor at specific time points
#' times <- seq(0, 60, by = 0.1)
#' response <- evaluate(reg, times)
#' @importFrom assertthat assert_that
#' @export
regressor <- Reg # Assign Reg directly to regressor


#' Create an Empty Regressor Object
#' 
#' A convenience function to create a regressor object representing no events. 
#' Useful for placeholder or baseline scenarios.
#' 
#' @param hrf The HRF object to associate (defaults to `HRF_SPMG1`).
#' @param span The span to associate (defaults to 24).
#' @return A `Reg` object representing zero events.
#' @noRd
null_regressor <- function(hrf=HRF_SPMG1, span=24) {
  # Calls Reg directly, ensuring amplitude=0 triggers empty result
  Reg(onsets = numeric(0), hrf = hrf, span = span, amplitude = 0) 
}


#' Create a single trial regressor
#'
#' Creates a regressor object for modeling a single trial event in an fMRI experiment.
#' This is particularly useful for trial-wise analyses where each trial needs to be
#' modeled separately. The regressor represents the predicted BOLD response for a single
#' event using a specified hemodynamic response function (HRF).
#'
#' This is a convenience wrapper around `regressor` that ensures inputs have length 1.
#'
#' @param onsets the event onset in seconds, must be of length 1.
#' @param hrf a hemodynamic response function, e.g. \code{HRF_SPMG1}
#' @param duration duration of the event (default is 0), must be length 1.
#' @param amplitude scaling vector (default is 1), must be length 1.
#' @param span the temporal window of the impulse response function (default is 24).
#' @return A `Reg` object (inheriting from `regressor` and `list`).
#' @examples
#' # Create single trial regressor at 10 seconds
#' str1 <- single_trial_regressor(onsets = 10, hrf = HRF_SPMG1)
#' 
#' # Single trial with duration and custom amplitude
#' str2 <- single_trial_regressor(
#'   onsets = 15,
#'   duration = 3,
#'   amplitude = 2,
#'   hrf = HRF_SPMG1
#' )
#' 
#' # Evaluate the response
#' times <- seq(0, 40, by = 0.1)
#' response <- evaluate(str1, times)
#' @seealso \code{\link{regressor}}
#' @importFrom assertthat assert_that
#' @export
single_trial_regressor <- function(onsets, hrf=HRF_SPMG1, duration=0, amplitude=1, span=24) {
  # Basic validation specific to single trial before calling Reg
  assertthat::assert_that(
    length(onsets) == 1,
    msg = "`onsets` must be of length 1"
  )
  assertthat::assert_that(
    length(duration) <= 1,
    msg = "`duration` must have length 1 or be a scalar"
  )
  assertthat::assert_that(
    length(amplitude) <= 1,
    msg = "`amplitude` must have length 1 or be a scalar"
  )
  
  # Call Reg constructor, which now sets correct classes
  Reg(onsets       = onsets,
      hrf          = hrf,
      duration     = duration,
      amplitude    = amplitude,
      span         = span, # Keep original default span 
      summate      = TRUE)
}
</file>

<file path="R/reg-methods.R">
# Evaluate method for Reg objects
#' 
#' This is the primary method for evaluating regressor objects created by the `Reg` constructor
#' (and thus also works for objects created by `regressor`).
#' It dispatches to different internal methods based on the `method` argument.
#' 
#' @rdname evaluate
#' @param x A `Reg` object (or an object inheriting from it, like `regressor`).
#' @param grid Numeric vector specifying the time points (seconds) for evaluation.
#' @param precision Numeric sampling precision for internal HRF evaluation and convolution (seconds).
#' @param method The evaluation method: 
#'   \itemize{
#'     \item{"conv"}{ (Default) Uses the C++ direct convolution (`evaluate_regressor_convolution`). Generally safer and more predictable.}
#'     \item{"fft"}{ Uses the fast C++ FFT convolution (`evaluate_regressor_fast`). Can be faster but may fail with very fine precision or wide grids.  
#'       Extremely fine `precision` or wide `grid` ranges may trigger an internal FFT size exceeding ~1e7, which results in an error.}
#'     \item{"Rconv"}{ Uses an R-based convolution (`stats::convolve`). Requires constant event durations and a regular sampling grid. Can be faster than the R loop for many events meeting these criteria.}
#'     \item{"loop"}{ Uses a pure R implementation involving looping through onsets. Can be slower, especially for many onsets.}
#'   }
#' @param sparse Logical indicating whether to return a sparse matrix (from the Matrix package). Default is FALSE.
#' @param ... Additional arguments passed down (e.g., to `evaluate.HRF` in the loop method).
#' @examples
#' # Create a regressor
#' reg <- regressor(onsets = c(10, 30, 50), hrf = HRF_SPMG1)
#' 
#' # Evaluate with default method (conv)
#' times <- seq(0, 80, by = 0.5)
#' response <- evaluate(reg, times)
#' 
#' # Try different evaluation methods
#' response_fft <- evaluate(reg, times, method = "fft")
#' response_loop <- evaluate(reg, times, method = "loop")
#' 
#' # With higher precision
#' response_precise <- evaluate(reg, times, precision = 0.1)
#' @export
#' @method evaluate Reg
#' @importFrom Matrix Matrix
#' @importFrom memoise memoise
#' @importFrom stats approx median convolve
#' @importFrom Rcpp evalCpp
evaluate.Reg <- function(x, grid, precision=.33, method=c("conv", "fft", "Rconv", "loop"), sparse = FALSE, ...) {

  method <- match.arg(method)

  # Validate inputs
  if (!is.numeric(grid) || length(grid) == 0 || anyNA(grid)) {
    stop("`grid` must be a non-empty numeric vector with no NA values.",
         call. = FALSE)
  }
  if (!is.numeric(precision) || length(precision) != 1 || is.na(precision) ||
      precision <= 0) {
    stop("`precision` must be a positive numeric value.", call. = FALSE)
  }

  # Prepare inputs using the helper function
  prep_data <- prep_reg_inputs(x, grid, precision)
  
  # Check if prep_reg_inputs indicated no relevant events
  if (length(prep_data$valid_ons) == 0) {
    zero_res <- if (prep_data$nb == 1) {
      rep(0, length(grid))
    } else {
      matrix(0, nrow = length(grid), ncol = prep_data$nb)
    }
    if (sparse) {
      zero_res <- Matrix::Matrix(zero_res, sparse = TRUE)
    }
    return(zero_res)
  }
  
  # --- Method Dispatch to Internal Engines ---
  eng_fun <- switch(method,
     conv  = eval_conv,   # Now the default - safer direct convolution
     fft   = eval_fft,    # FFT-based (faster but can fail with large FFT sizes)
     Rconv = eval_Rconv,  # R-based convolution
     loop  = eval_loop,   # Pure R loop implementation
     stop("Invalid evaluation method: ", method) # Should not happen due to match.arg
  )
  
  # Call the selected engine function with prepared data
  # Pass ... through to the engine, which might pass it to evaluate.HRF in loop
  result <- eng_fun(prep_data, ...) 
  
  # --- Final Formatting ---
  nb <- prep_data$nb
  final_result <- if (nb == 1 && is.matrix(result)) {
    as.vector(result)
  } else if (nb > 1 && !is.matrix(result)) {
    matrix(result, nrow=length(grid), ncol=nb)
  } else {
      result
  }
  
  # Convert to sparse matrix if requested
  if (sparse) {
    return(Matrix::Matrix(final_result, sparse = TRUE))
  } else {
    return(final_result)
  }
}


#' @method shift Reg
#' @rdname shift
#' @export
#' @importFrom assertthat assert_that
shift.Reg <- function(x, shift_amount, ...) {
  dots <- list(...)

  if (missing(shift_amount) && "offset" %in% names(dots)) {
    shift_amount <- dots$offset
  }

  assert_that(inherits(x, "Reg"),
              msg = "Input 'x' must inherit from class 'Reg'")

  if (missing(shift_amount)) {
    stop("Must supply `shift_amount` or `offset`.", call. = FALSE)
  }

  assert_that(is.numeric(shift_amount) && length(shift_amount) == 1,
              msg = "`shift_amount` must be a single numeric value")

  # Handle empty regressor case
  if (length(x$onsets) == 0 || (length(x$onsets) == 1 && is.na(x$onsets[1]))) {
    # Returning the original empty object is appropriate for a shift
    return(x)
  }

  # Shift the valid onsets
  shifted_onsets <- x$onsets + shift_amount

  # Reconstruct the object using the core Reg constructor 
  out <- Reg(onsets = shifted_onsets,
             hrf = x$hrf,
             duration = x$duration,
             amplitude = x$amplitude,
             span = x$span,
             summate = x$summate)
             
  return(out)
}

#' Print method for Reg objects
#' 
#' Provides a concise summary of the regressor object using the cli package.
#' 
#' @param x A `Reg` object.
#' @param ... Not used.
#' @importFrom cli cli_h1 cli_text cli_div cli_li
#' @export
#' @method print Reg
#' @rdname print
print.Reg <- function(x, ...) {
  
  n_ons <- length(x$onsets)
  hrf_name <- attr(x$hrf, "name") %||% "custom function"
  nb <- nbasis(x$hrf)
  hrf_span <- attr(x$hrf, "span") %||% x$span
  
  cli::cli_h1("fMRI Regressor Object")
  
  # Use cli_div for potentially better alignment than cli_ul
  cli::cli_div(theme = list(ul = list("margin-left" = 2), li = list("margin-bottom" = 0.5)))
  cli::cli_li("Type: {.cls {class(x)[1]}}{if(inherits(x, 'regressor')) ' (Legacy compatible)'}")
  if (n_ons == 0) {
    cli::cli_li("Events: 0 (Empty Regressor)")
  } else {
    cli::cli_li("Events: {n_ons}")
    cli::cli_li("Onset Range: {round(min(x$onsets), 2)}s to {round(max(x$onsets), 2)}s")
    if (any(x$duration != 0)) {
      cli::cli_li("Duration Range: {round(min(x$duration), 2)}s to {round(max(x$duration), 2)}s")
    }
    if (!all(x$amplitude == 1)) {
      cli::cli_li("Amplitude Range: {round(min(x$amplitude), 2)} to {round(max(x$amplitude), 2)}")
    }
  }
  cli::cli_li("HRF: {hrf_name} ({nb} basis function{?s})")
  cli::cli_li("HRF Span: {hrf_span}s")
  cli::cli_li("Summation: {x$summate}")
  cli::cli_end()

  invisible(x)
}

# S3 Methods for Reg class -----

#' @export
#' @rdname nbasis
#' @method nbasis Reg
nbasis.Reg <- function(x, ...) nbasis(x$hrf)

#' @export
#' @rdname onsets
#' @method onsets Reg
onsets.Reg <- function(x, ...) x$onsets

#' @export
#' @rdname durations
#' @method durations Reg
durations.Reg <- function(x, ...) x$duration

#' @export
#' @rdname amplitudes
#' @method amplitudes Reg
amplitudes.Reg <- function(x, ...) x$amplitude
</file>

<file path="R/sampling_frame.R">
#' @noRd
#' @keywords internal
new_sampling_frame <- function(blocklens, TR, start_time, precision) {
  structure(
    list(blocklens = blocklens,
         TR        = TR,
         start_time = start_time,
         precision = precision),
    class = "sampling_frame")
}

#'
#' A \code{sampling_frame} describes the block structure and temporal sampling of an fMRI paradigm.
#'
#' @param blocklens A numeric vector representing the number of scans in each block.
#' @param TR A numeric value or vector representing the repetition time in seconds
#'   (i.e., the spacing between consecutive image acquisitions). When a vector is
#'   provided, its length must be 1 or equal to the number of blocks.
#' @param start_time A numeric value or vector representing the offset of the first
#'   scan of each block (default is \code{TR/2}). When a vector is provided, its
#'   length must be 1 or equal to the number of blocks.
#' @param precision A numeric value representing the discrete sampling interval used for convolution with the hemodynamic response function (default is 0.1).
#'
#' @examples
#' frame <- sampling_frame(blocklens = c(100, 100, 100), TR = 2, precision = 0.5)
#'
#' # The relative time (with respect to the last block) in seconds of each sample/acquisition
#' sam <- samples(frame)
#' # The global time (with respect to the first block) of each sample/acquisition
#' gsam <- samples(frame, global = TRUE)
#'
#' # Block identifiers for each acquisition can be retrieved using
#' # blockids(frame)
#'
#' @return A list with class "sampling_frame" describing the block structure and temporal sampling of an fMRI paradigm.
#' @export
sampling_frame <- function(blocklens, TR, start_time = TR / 2, precision = .1)
{
  # --- recycle & validate ------------------------------------------------
  n_blocks <- length(blocklens)

  # Check that TR and start_time are either length 1 or match n_blocks
  if (length(TR) != 1L && length(TR) != n_blocks) {
    stop("TR must have length 1 or match the number of blocks")
  }
  if (length(start_time) != 1L && length(start_time) != n_blocks) {
    stop("start_time must have length 1 or match the number of blocks")
  }

  # Recycle values to the number of blocks
  TR <- rep_len(TR, n_blocks)
  start_time <- rep_len(start_time, n_blocks)
  
  # Validate inputs with proper error messages
  if (!is.numeric(blocklens) || any(is.na(blocklens))) {
    stop("Block lengths must be numeric and non-NA")
  }
  if (!is.numeric(TR) || any(is.na(TR))) {
    stop("TR values must be numeric and non-NA")
  }
  if (!is.numeric(start_time) || any(is.na(start_time))) {
    stop("Start times must be numeric and non-NA")
  }
  if (!all(blocklens > 0)) {
    stop("Block lengths must be positive")
  }
  if (!all(TR > 0)) {
    stop("TR values must be positive")
  }
  if (!all(start_time >= 0)) {
    stop("Start times must be non-negative")
  }
  if (precision <= 0) {
    stop("Precision must be positive")
  }
  if (precision >= min(TR)) {
    stop("Precision must be positive and less than the minimum TR")
  }

  new_sampling_frame(blocklens, TR, start_time, precision)
}


#' @method samples sampling_frame
#' @rdname samples
#' @export
samples.sampling_frame <- function(x, blockids = NULL, global = FALSE,...) {
  if (is.null(blockids)) blockids <- seq_along(x$blocklens)

  # number of scans per selected block
  lens <- x$blocklens[blockids]

  # fast allocate
  idx <- sequence(lens) - 1                   # 0‑based within block
  
  # Calculate relative times within each block
  block_times <- rep(blockids, lens)  # which block each sample belongs to
  times <- x$start_time[block_times] + idx * x$TR[block_times]

  if (global) {
    # For global timing, add the cumulative time offset from previous blocks
    # Calculate cumulative time at the end of each block
    block_durations <- x$blocklens * x$TR
    cumulative_time <- c(0, cumsum(block_durations))
    
    # Add the cumulative time offset for each block
    time_offsets <- cumulative_time[block_times]
    times + time_offsets
  } else {
    times
  }
}

#' @method global_onsets sampling_frame
#' @rdname global_onsets
#' @param blockids Integer vector identifying the block for each onset. Values
#'   must be whole numbers with no NAs.
#' @export
global_onsets.sampling_frame <- function(x, onsets, blockids,...) {
  # Calculate cumulative time offsets for each block
  block_durations <- x$blocklens * x$TR
  cumulative_time <- c(0, cumsum(block_durations))

  if (!is.numeric(blockids) || anyNA(blockids) || any(blockids %% 1 != 0)) {
    stop("blockids must be whole numbers and not NA")
  }
  blockids <- as.integer(blockids)
  stopifnot(length(onsets) == length(blockids),
            all(blockids >= 1L), all(blockids <= length(x$blocklens)))

  onsets + cumulative_time[blockids]
}

#' @export
#' @rdname print
print.sampling_frame <- function(x, ...) {
  n_blk <- length(x$blocklens)
  total_scans <- sum(x$blocklens)
  
  cat("Sampling Frame\n")
  cat("==============\n\n")
  
  cat("Structure:\n")
  cat(sprintf("  %d block%s\n", n_blk, if (n_blk > 1) "s" else ""))
  cat(sprintf("  Total scans: %d\n\n", total_scans))
  
  cat("Timing:\n")
  cat(sprintf("  TR: %s s\n", paste(unique(x$TR), collapse = ", ")))
  cat(sprintf("  Precision: %.3g s\n\n", x$precision))
  
  cat("Duration:\n")
  total_time <- sum(x$blocklens * x$TR)
  cat(sprintf("  Total time: %.1f s\n", total_time))
  
  invisible(x)
}


#' @rdname blockids
#' @export
blockids.sampling_frame <- function(x, ...) {
  rep(seq_along(x$blocklens), times = x$blocklens)
}


#' @rdname blocklens
#' @export
blocklens.sampling_frame <- function(x,...) {
    x$blocklens
}


#' @rdname acquisition_onsets
#' @method acquisition_onsets sampling_frame
#' @export
acquisition_onsets.sampling_frame <- function(x, ...) {
  samples(x, global = TRUE)
}
</file>

<file path="R/hrf.R">
#' Turn any function into an HRF object
#'
#' This is the core constructor for creating HRF objects in the refactored system.
#' It takes a function `f(t)` and attaches standard HRF attributes.
#'
#' @param f The function to be turned into an HRF object. It must accept a single argument `t` (time).
#' @param name The name for the HRF object. Defaults to the deparsed name of `f`.
#' @param nbasis The number of basis functions represented by `f`. Must be \code{>= 1}. Defaults to 1L.
#' @param span The nominal time span (duration in seconds) of the HRF. Must be positive. Defaults to 24.
#' @param params A named list of parameters associated with the HRF function `f`. Defaults to an empty list.
#' @return A new HRF object.
#' @keywords internal
#' @export
as_hrf <- function(f, name = deparse(substitute(f)), nbasis = 1L, span = 24,
                   params = list()) {
  assertthat::assert_that(is.function(f))
  assertthat::assert_that(is.character(name), length(name) == 1)
  assertthat::assert_that(is.numeric(nbasis), length(nbasis) == 1)
  assertthat::assert_that(nbasis >= 1, msg = "nbasis must be >= 1")
  assertthat::assert_that(is.numeric(span), length(span) == 1)
  assertthat::assert_that(span > 0, msg = "span must be > 0")
  assertthat::assert_that(is.list(params))

  structure(
    f,
    class        = c("HRF", "function"),
    name         = name,
    nbasis       = as.integer(nbasis),
    span         = span,
    param_names  = names(params),
    params       = params
  )
}


#' Bind HRFs into a Basis Set
#'
#' Combines multiple HRF objects into a single multi-basis HRF object.
#' The resulting function evaluates each input HRF at time `t` and returns the results column-bound together.
#'
#' @param ... One or more HRF objects created by `as_hrf` or other HRF constructors/decorators.
#'
#' @return A new HRF object representing the combined basis set.
#'
#' @keywords internal
#' @export
#' @importFrom assertthat assert_that
bind_basis <- function(...) {
  xs <- list(...)
  assertthat::assert_that(length(xs) > 0, msg = "bind_basis requires at least one HRF object.")
  assertthat::assert_that(all(sapply(xs, inherits, "HRF")), msg = "All inputs to bind_basis must be HRF objects.")

  # Handle single HRF case explicitly
  if (length(xs) == 1) {
    return(xs[[1]])
  }

  # Calculate combined attributes
  combined_nbasis <- sum(vapply(xs, attr, 0L, "nbasis"))
  combined_span <- max(vapply(xs, attr, 0, "span"))
  combined_name <- paste(sapply(xs, attr, "name"), collapse = " + ")

  # Create the combined function
  combined_func <- function(t) {
    do.call(cbind, lapply(xs, function(f) f(t)))
  }

  # Use as_hrf to create the new HRF object
  as_hrf(
    f = combined_func,
    name = combined_name,
    nbasis = combined_nbasis,
    span = combined_span,
    params = list() # Params usually don't combine meaningfully
  )
}


#' Construct an HRF Instance using Decorators
#' 
#' @description
#' `gen_hrf` takes a base HRF function or object and applies optional lag,
#' blocking, and normalization decorators based on arguments.
#'
#' @param hrf A function `f(t)` or an existing `HRF` object.
#' @param lag Optional lag in seconds. If non-zero, applies `lag_hrf`.
#' @param width Optional block width in seconds. If non-zero, applies `block_hrf`.
#' @param precision Sampling precision for block convolution (passed to `block_hrf`). Default is 0.1.
#' @param half_life Half-life decay parameter for exponential decay in seconds (passed to `block_hrf`). Default is Inf (no decay).
#' @param summate Whether to summate within blocks (passed to `block_hrf`). Default is TRUE.
#' @param normalize If TRUE, applies `normalise_hrf` at the end. Default is FALSE.
#' @param name Optional name for the *final* HRF object. If NULL (default), a name is generated based on the base HRF and applied decorators.
#' @param span Optional span for the *final* HRF object. If NULL (default), the span is determined by the base HRF and decorators.
#' @param ... Extra arguments passed to the *base* HRF function if `hrf` is a function.
#'
#' @return A final `HRF` object, potentially modified by decorators.
#' 
#' @examples 
#' # Lagged SPMG1
#' grf_lag <- gen_hrf(HRF_SPMG1, lag=3)
#' # Blocked Gaussian
#' grf_block <- gen_hrf(hrf_gaussian, width=5, precision=0.2)
#' # Lagged and Blocked, then Normalized
#' grf_both_norm <- gen_hrf(HRF_SPMG1, lag=2, width=4, normalize=TRUE)
#'
#' @export
gen_hrf <- function(hrf, lag=0, width=0, precision=.1, half_life=Inf,
                    summate=TRUE, normalize=FALSE, name=NULL, span=NULL, ...) {

  # 1. Ensure we start with an HRF object
  if (is.function(hrf) && !inherits(hrf, "HRF")) {
    # If it's a plain function, convert it using as_hrf
    # Determine nbasis by evaluating the function
    test_t <- 1:10 # A small sample range
    test_val <- try(hrf(test_t, ...), silent = TRUE)
    determined_nbasis <- if (!inherits(test_val, "try-error") && !is.null(test_val)) {
      if (is.matrix(test_val)) ncol(test_val) else 1L
    } else {
      warning(paste("Could not determine nbasis for function", deparse(substitute(hrf)), "- defaulting to 1. Evaluation failed."))
      1L
    }
    
    # Pass extra args (...) here if they are meant for the base function construction
    base_hrf <- as_hrf(f = function(t) hrf(t, ...),
                       name = deparse(substitute(hrf)),
                       nbasis = determined_nbasis) # Pass determined nbasis
                       # Let as_hrf determine default span, params
  } else if (inherits(hrf, "HRF")) {
    # If already an HRF object, use it directly
    base_hrf <- hrf
    if (length(list(...)) > 0) {
      warning("Ignoring extra arguments (...) because 'hrf' is already an HRF object.")
    }
  } else {
    stop("'hrf' must be a function or an HRF object.")
  }

  # Apply decorators conditionally
  decorated_hrf <- base_hrf

  # Apply width decorator first if needed
  if (width != 0) {
    # Check positivity *before* applying
    stopifnot(width > 0)
    # Note: block_hrf handles normalize=FALSE internally by default
    decorated_hrf <- block_hrf(decorated_hrf, width=width, precision=precision,
                               half_life=half_life, summate=summate, normalize=FALSE)
  }

  # Apply lag decorator if needed
  if (lag != 0) {
    decorated_hrf <- lag_hrf(decorated_hrf, lag=lag)
  }

  # Apply normalization decorator last if needed
  if (normalize) {
    decorated_hrf <- normalise_hrf(decorated_hrf)
  }

  # Override name and span if provided by user
  if (!is.null(name)) {
    attr(decorated_hrf, "name") <- name
  }
  if (!is.null(span)) {
    attr(decorated_hrf, "span") <- span
  }

  # Return the final (potentially decorated) HRF object
  return(decorated_hrf)
}


#' Generate an Empirical Hemodynamic Response Function
#' 
#' @description
#' `empirical_hrf` generates an empirical HRF using provided time points and values.
#' 
#' @param t Time points.
#' @param y Values of HRF at time `t[i]`.
#' @param name Name of the generated HRF.
#' @return An instance of type `HRF`.
#' @examples
#' # Create empirical HRF from data points
#' t_points <- seq(0, 20, by = 1)
#' y_values <- c(0, 0.1, 0.5, 0.9, 1.0, 0.8, 0.5, 0.2, 0, -0.1, -0.1, 
#'               0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
#' emp_hrf <- empirical_hrf(t_points, y_values)
#' 
#' # Evaluate at new time points
#' new_times <- seq(0, 25, by = 0.1)
#' response <- evaluate(emp_hrf, new_times)
#' @export
empirical_hrf <- function(t, y, name = "empirical_hrf") {
  as_hrf(stats::approxfun(t, y, yright = 0, yleft = 0),
         name = name, nbasis = 1L, span = max(t, na.rm = TRUE))
}

#' @export
#' @rdname empirical_hrf
#' @keywords internal
gen_empirical_hrf <- function(...) {
  .Deprecated("empirical_hrf")
  empirical_hrf(...)
}


#' Generate an HRF Basis Set
#' 
#' @description
#' `hrf_set` constructs an HRF basis set from one or more component HRF objects.
#'
#' @param ... One or more HRF objects.
#' @param name The name for the combined HRF set.
#' @return A combined HRF object.
#' @examples
#' # Combine multiple HRF types into a basis set
#' hrf_basis <- hrf_set(HRF_SPMG1, HRF_GAUSSIAN, HRF_GAMMA)
#' 
#' # Create custom basis with different parameters
#' hrf1 <- gen_hrf(hrf_gamma, alpha = 6, beta = 1)
#' hrf2 <- gen_hrf(hrf_gamma, alpha = 8, beta = 1)
#' custom_basis <- hrf_set(hrf1, hrf2, name = "custom_gamma_basis")
#' 
#' # Evaluate the basis set
#' t <- seq(0, 30, by = 0.1)
#' basis_response <- evaluate(hrf_basis, t)
#' @export
hrf_set <- function(..., name = "hrf_set") {
  combined_hrf <- bind_basis(...)
  attr(combined_hrf, "name") <- name
  combined_hrf
}

#' @export
#' @rdname hrf_set
#' @keywords internal
gen_hrf_set <- function(...) {
  .Deprecated("hrf_set")
  hrf_set(...)
}


#' Generate an HRF library from a parameter grid
#'
#' @description
#' `hrf_library` applies a base HRF generating function to each row of a parameter grid.
#'
#' @param fun A function that generates an HRF, given a set of parameters.
#' @param pgrid A data frame where each row is a set of parameters.
#' @param ... Additional arguments passed to `fun`.
#' @return A combined HRF object representing the library.
#' @examples
#' # Create library of gamma HRFs with varying parameters
#' param_grid <- expand.grid(
#'   alpha = c(6, 8, 10),
#'   beta = c(0.9, 1, 1.1)
#' )
#' gamma_library <- hrf_library(hrf_gamma, param_grid)
#' 
#' # Create library with fixed and varying parameters
#' param_grid2 <- expand.grid(lag = c(0, 2, 4))
#' lagged_library <- hrf_library(
#'   function(lag) gen_hrf(HRF_SPMG1, lag = lag),
#'   param_grid2
#' )
#' @importFrom purrr pmap partial
#' @export
hrf_library <- function(fun, pgrid, ...) {
  extras <- list(...)
  # Ensure fun returns an HRF object
  hrf_list <- purrr::pmap(pgrid, function(...) {
      params <- list(...)
      do.call(fun, c(params, extras))
  })
  # Bind the generated HRFs
  do.call(bind_basis, hrf_list)
}

#' @export
#' @rdname hrf_library
#' @keywords internal
gen_hrf_library <- function(...) {
  .Deprecated("hrf_library")
  hrf_library(...)
}


#' HRF Constructor Function
#'
#' The `HRF` function creates an object representing a hemodynamic response function (HRF). It is a class constructor for HRFs.
#'
#' @param fun A function representing the hemodynamic response, mapping from time to BOLD response.
#' @param name A string specifying the name of the function.
#' @param nbasis An integer representing the number of basis functions, e.g., the columnar dimension of the HRF. Default is 1.
#' @param span A numeric value representing the span in seconds of the HRF. Default is 24.
#' @param param_names A character vector containing the names of the parameters for the HRF function.
#'
#' @return An HRF object with the specified properties.
#'
#' @details
#' The package provides several pre-defined HRF types that can be used in modeling fMRI responses:
#'
#' **Canonical HRFs:**
#' * `"spmg1"` or `HRF_SPMG1`: SPM's canonical HRF (single basis function)
#' * `"spmg2"` or `HRF_SPMG2`: SPM canonical + temporal derivative (2 basis functions)
#' * `"spmg3"` or `HRF_SPMG3`: SPM canonical + temporal and dispersion derivatives (3 basis functions)
#' * `"gaussian"` or `HRF_GAUSSIAN`: Gaussian-shaped HRF with peak around 5-6s
#' * `"gamma"` or `HRF_GAMMA`: Gamma function-based HRF with longer tail
#'
#' **Flexible basis sets:**
#' * `"bspline"` or `"bs"` or `HRF_BSPLINE`: B-spline basis for flexible HRF modeling
#' * `"tent"`: Tent (triangular) basis functions for flexible HRF modeling
#' * `"daguerre"` or `HRF_DAGUERRE`: Daguerre basis functions
#'
#' To see a complete list of available HRF types with details, use the `list_available_hrfs()` function.
#'
#' @examples
#' hrf <- HRF(hrf_gamma, "gamma", nbasis=1, param_names=c("shape", "rate"))
#' resp <- evaluate(hrf, seq(0, 24, by=1))
#'
#' # List all available HRF types
#' list_available_hrfs(details = TRUE)
#'
#' @export
#' @rdname HRF-class
HRF <- function(fun, name, nbasis=1, span=24, param_names=NULL) {
  vals <- try(fun(seq(0, span)), silent = TRUE)

  peak <- if (!inherits(vals, "try-error") && !is.null(vals)) {
    if (nbasis == 1) {
      max(vals, na.rm = TRUE)
    } else if (is.matrix(vals)) {
      max(apply(vals, 2, max, na.rm = TRUE))
    } else {
      NA # Unable to determine peak
    }
  } else {
    NA # Error during evaluation or null result
  }

  scale_factor <- if (!is.na(peak) && peak != 0) {
    1 / peak
  } else {
    NA # Cannot compute scale_factor if peak is NA or zero
  }
  
  structure(fun, name=name, 
            nbasis=as.integer(nbasis), 
            span=span,
            param_names=param_names, 
            scale_factor=scale_factor, 
            class=c("HRF", "function"))
  
}

#' @rdname nbasis
#' @export
nbasis.HRF <- function(x,...) attr(x, "nbasis")



#' @keywords internal
#' @noRd
makeDeriv <- function(HRF, n=1) {
  #with_package("numDeriv")
  if (n == 1) {
    function(t) numDeriv::grad(HRF, t)
  } else {
    Recall(function(t) numDeriv::grad(HRF,t), n-1)
  }
}


#' Generate a Lagged HRF Function
#'
#' @description
#' The `gen_hrf_lagged` function takes an HRF function and applies a specified lag to it. This can be useful for modeling time-delayed hemodynamic responses.
#'
#' @param hrf A function representing the underlying HRF to be shifted.
#' @param lag A numeric value specifying the lag or delay in seconds to apply to the HRF. This can also be a vector of lags, in which case the function returns an HRF set.
#' @param normalize A logical value indicating whether to rescale the output so that the maximum absolute value is 1. Defaults to `FALSE`.
#' @param ... Extra arguments supplied to the `hrf` function.
#'
#' @return A function representing the lagged HRF. If `lag` is a vector of lags, the function returns an HRF set.
#' @family gen_hrf
#' @examples
#' \donttest{
#' hrf_lag5 <- gen_hrf_lagged(HRF_SPMG1, lag=5)
#' hrf_lag5(0:20)
#' }
#'
#' @export
gen_hrf_lagged <- function(hrf, lag=2, normalize=FALSE, ...) {
  force(hrf)
  # TODO deal with nbasis arg in ...
  if (length(lag)>1) {
    do.call(gen_hrf_set, lapply(lag, function(l) gen_hrf_lagged(hrf, l,...)))
  } else {
    function(t) {
      ret <- hrf(t-lag,...)
      if (normalize) {
        ret <- ret/max(abs(ret))
      } 
      
      ret
    }
  }
}

#' @export
#' @describeIn gen_hrf_lagged alias for gen_hrf_lagged
#' @family gen_hrf
#' @return an lagged hrf function
hrf_lagged <- gen_hrf_lagged


#' Generate a Blocked HRF Function
#'
#' @description
#' The `gen_hrf_blocked` function creates a blocked HRF by convolving the input HRF with a boxcar function. This can be used to model block designs in fMRI analysis.
#'
#' @param hrf A function representing the hemodynamic response function. Default is `hrf_gaussian`.
#' @param width A numeric value specifying the width of the block in seconds. Default is 5.
#' @param precision A numeric value specifying the sampling resolution in seconds. Default is 0.1.
#' @param half_life A numeric value specifying the half-life of the exponential decay function, used to model response attenuation. Default is `Inf`, which means no decay.
#' @param summate A logical value indicating whether to allow each impulse response function to "add" up. Default is `TRUE`.
#' @param normalize A logical value indicating whether to rescale the output so that the peak of the output is 1. Default is `FALSE`.
#' @param ... Extra arguments passed to the HRF function.
#' @family gen_hrf
#'
#' @return A \code{function} representing the blocked HRF.
#'
#' @importFrom purrr partial
#' @export
gen_hrf_blocked <- function(hrf=hrf_gaussian, width=5, precision=.1, 
                            half_life=Inf, summate=TRUE, normalize=FALSE, ...) {
  # Deprecated - use gen_hrf with width parameter instead
  .Deprecated("gen_hrf")
  gen_hrf(hrf, width=width, precision=precision, half_life=half_life, 
          summate=summate, normalize=normalize, ...)
}

#' @export
#' @aliases gen_hrf_blocked
#' @describeIn gen_hrf_blocked alias for gen_hrf_blocked
#' @return A \code{function} representing the blocked HRF.
hrf_blocked <- gen_hrf_blocked





#' Soft-threshold function
#'
#' This function applies soft-thresholding to the input values, setting values below the threshold to zero
#' and shrinking the remaining values by the threshold amount.
#'
#' @param x A numeric vector of input values
#' @param threshold A non-negative threshold value for the soft-thresholding operation
#'
#' @return A numeric vector with the soft-thresholded values
#'
#' @noRd
#' @keywords internal
soft_threshold <- function(x, threshold) {
  if (threshold < 0) {
    stop("Threshold value should be non-negative.")
  }

  sign(x) * pmax(0, abs(x) - threshold)
}



#' List all available hemodynamic response functions (HRFs)
#'
#' @description
#' Reads the internal HRF registry to list available HRF types.
#'
#' @param details Logical; if TRUE, attempt to add descriptions (basic for now).
#' @return A data frame with columns: name, type (object/generator), nbasis_default.
#' @examples
#' # List all available HRFs
#' hrfs <- list_available_hrfs()
#' print(hrfs)
#' 
#' # List with details
#' hrfs_detailed <- list_available_hrfs(details = TRUE)
#' print(hrfs_detailed)
#' @export
list_available_hrfs <- function(details = FALSE) {
  # Get names directly from the registry
  hrf_names <- names(HRF_REGISTRY)
  
  # Determine type and default nbasis by inspecting registry entries
  hrf_info <- lapply(hrf_names, function(name) {
    entry <- HRF_REGISTRY[[name]]
    type <- if (inherits(entry, 'HRF')) "object" else if (is.function(entry)) "generator" else "unknown"
    
    nbasis_default <- NA
    if (type == "object") {
      nbasis_default <- tryCatch(nbasis(entry), error = function(e) NA)
    } else if (type == "generator") {
      fmls <- formals(entry)
      if ("nbasis" %in% names(fmls)) {
        nb_val <- fmls$nbasis
        if(is.numeric(nb_val)) nbasis_default <- nb_val 
      } 
      if(is.na(nbasis_default)) nbasis_default <- "variable"
    }
    
    # Check if this name is an alias (points to the same object/func as another primary name)
    is_alias <- FALSE
    if (type == "object") {
      primary_names <- names(HRF_REGISTRY)[sapply(HRF_REGISTRY, identical, entry)]
      is_alias <- length(primary_names) > 1 && name %in% primary_names[primary_names != name]
    } else if (type == "generator") {
      # More complex for functions, check if it points to the same generator function
      # For now, let's assume aliases only exist for objects, or mark known ones
      is_alias <- name %in% c("gam", "bs")
    }

    list(name = name, type = type, nbasis_default = as.character(nbasis_default), is_alias = is_alias) 
  })
  
  # Combine into a data frame
  hrf_df <- do.call(rbind.data.frame, c(hrf_info, list(stringsAsFactors = FALSE)))
  
  # Add basic descriptions if requested
  if (details) {
      hrf_df$description <- paste(hrf_df$name, "HRF", 
                                  ifelse(hrf_df$type == "generator", "(generator)", "(object)"),
                                  ifelse(hrf_df$is_alias, "(alias)", ""))
  }
  
  hrf_df
}

# Define Static HRF Objects -----

#' Pre-defined Hemodynamic Response Function Objects
#' 
#' A collection of pre-defined HRF objects for common fMRI analysis scenarios.
#' These objects can be used directly in model specifications or as templates
#' for creating custom HRFs.
#' 
#' @section Canonical HRFs:
#' \describe{
#'   \item{\code{HRF_SPMG1}}{SPM canonical HRF (single basis function)}
#'   \item{\code{HRF_SPMG2}}{SPM canonical HRF with temporal derivative (2 basis functions)}
#'   \item{\code{HRF_SPMG3}}{SPM canonical HRF with temporal and dispersion derivatives (3 basis functions)}
#'   \item{\code{HRF_GAMMA}}{Gamma function-based HRF}
#'   \item{\code{HRF_GAUSSIAN}}{Gaussian function-based HRF}
#' }
#' 
#' @section Flexible Basis Sets:
#' \describe{
#'   \item{\code{HRF_BSPLINE}}{B-spline basis HRF (5 basis functions)}
#'   \item{\code{HRF_FIR}}{Finite Impulse Response (FIR) basis HRF (12 basis functions)}
#' }
#' 
#' @section Creating Custom Basis Sets:
#' The pre-defined objects above have fixed numbers of basis functions. To create
#' basis sets with custom parameters (e.g., different numbers of basis functions),
#' use one of these approaches:
#' 
#' \strong{Using getHRF():}
#' \itemize{
#'   \item \code{getHRF("fir", nbasis = 20)} - FIR basis with 20 functions
#'   \item \code{getHRF("bspline", nbasis = 10, span = 30)} - B-spline with 10 functions
#'   \item \code{getHRF("fourier", nbasis = 7)} - Fourier basis with 7 functions
#'   \item \code{getHRF("daguerre", nbasis = 5, scale = 3)} - Daguerre basis
#' }
#' 
#' \strong{Using generator functions directly:}
#' \itemize{
#'   \item \code{hrf_fir_generator(nbasis = 20, span = 30)}
#'   \item \code{hrf_bspline_generator(nbasis = 10, span = 30)}
#'   \item \code{hrf_fourier_generator(nbasis = 7, span = 24)}
#'   \item \code{hrf_daguerre_generator(nbasis = 5, scale = 3)}
#' }
#' 
#' @section Usage:
#' All HRF objects can be:
#' \itemize{
#'   \item Called as functions with time argument: \code{HRF_SPMG1(t)}
#'   \item Used in model specifications: \code{hrf(condition, basis = HRF_SPMG1)}
#'   \item Evaluated with \code{evaluate()} method
#'   \item Combined with decorators like \code{lag_hrf()} or \code{block_hrf()}
#' }
#' 
#' @param t Numeric vector of time points (in seconds) at which to evaluate the HRF
#' @param P1,P2 Shape parameters for SPM canonical HRF (default: P1=5, P2=15)
#' @param A1 Amplitude parameter for SPM canonical HRF (default: 0.0833)
#' @param shape,rate Parameters for gamma distribution HRF (default: shape=6, rate=1)
#' @param mean,sd Parameters for Gaussian HRF (default: mean=6, sd=2)
#' 
#' @return 
#' When called as functions, return numeric vectors or matrices of HRF values.
#' When used as objects, they are HRF objects with class \code{c("HRF", "function")}.
#' 
#' @examples
#' # Evaluate HRFs at specific time points
#' times <- seq(0, 20, by = 0.5)
#' 
#' # Single basis canonical HRF
#' canonical_response <- HRF_SPMG1(times)
#' plot(times, canonical_response, type = "l", main = "SPM Canonical HRF")
#' 
#' # Multi-basis HRF with derivatives
#' multi_response <- HRF_SPMG3(times)  # Returns 3-column matrix
#' matplot(times, multi_response, type = "l", main = "SPM HRF with Derivatives")
#' 
#' # Gamma and Gaussian HRFs
#' gamma_response <- HRF_GAMMA(times)
#' gaussian_response <- HRF_GAUSSIAN(times)
#' 
#' # Compare different HRF shapes
#' plot(times, canonical_response, type = "l", col = "blue", 
#'      main = "HRF Comparison", ylab = "Response")
#' lines(times, gamma_response, col = "red")
#' lines(times, gaussian_response, col = "green")
#' legend("topright", c("SPM Canonical", "Gamma", "Gaussian"), 
#'        col = c("blue", "red", "green"), lty = 1)
#' 
#' # Create custom FIR basis with 20 bins
#' custom_fir <- getHRF("fir", nbasis = 20, span = 30)
#' fir_response <- evaluate(custom_fir, times)
#' matplot(times, fir_response, type = "l", main = "Custom FIR with 20 bins")
#' 
#' # Create custom B-spline basis  
#' custom_bspline <- hrf_bspline_generator(nbasis = 8, span = 25)
#' bspline_response <- evaluate(custom_bspline, times)
#' matplot(times, bspline_response, type = "l", main = "Custom B-spline with 8 basis functions")
#' 
#' @name HRF_objects
#' @aliases HRF_SPMG1 HRF_SPMG2 HRF_SPMG3 HRF_GAMMA HRF_GAUSSIAN HRF_BSPLINE HRF_FIR
#' @family hrf
#' @seealso 
#' \code{\link{evaluate.HRF}} for evaluating HRF objects,
#' \code{\link{gen_hrf}} for creating HRFs with decorators,
#' \code{\link{list_available_hrfs}} for listing all HRF types,
#' \code{\link{getHRF}} for creating HRFs by name with custom parameters,
#' \code{\link{hrf_fir_generator}}, \code{\link{hrf_bspline_generator}}, 
#' \code{\link{hrf_fourier_generator}}, \code{\link{hrf_daguerre_generator}} 
#' for creating custom basis sets directly
NULL

#' @rdname HRF_objects
#' @export
HRF_GAMMA <- as_hrf(hrf_gamma, name="gamma", params=list(shape=6, rate=1))

#' @rdname HRF_objects
#' @export
HRF_GAUSSIAN <- as_hrf(hrf_gaussian, name="gaussian", params=list(mean=6, sd=2))

#' @rdname HRF_objects
#' @export
HRF_SPMG1 <- as_hrf(hrf_spmg1, name="SPMG1", params=list(P1=5, P2=15, A1=0.0833))

#' @rdname HRF_objects
#' @export
HRF_SPMG2 <- bind_basis(
  as_hrf(hrf_spmg1, name="SPMG1_canonical", params=list(P1=5, P2=15, A1=0.0833)),
  as_hrf(hrf_spmg1_deriv, name="SPMG1_temporal_deriv", params=list(P1=5, P2=15, A1=0.0833))
)
attr(HRF_SPMG2, "name") <- "SPMG2"
class(HRF_SPMG2) <- c("SPMG2_HRF", class(HRF_SPMG2))

#' @rdname HRF_objects
#' @export
HRF_SPMG3 <- bind_basis(
  as_hrf(hrf_spmg1, name="SPMG1_canonical", params=list(P1=5, P2=15, A1=0.0833)),
  as_hrf(hrf_spmg1_deriv, name="SPMG1_temporal_deriv", params=list(P1=5, P2=15, A1=0.0833)),
  as_hrf(hrf_spmg1_second_deriv, name="SPMG1_dispersion_deriv", params=list(P1=5, P2=15, A1=0.0833))
)
attr(HRF_SPMG3, "name") <- "SPMG3"
class(HRF_SPMG3) <- c("SPMG3_HRF", class(HRF_SPMG3))

# Define HRF Generators (Functions returning HRF objects) -----

#' Create B-spline HRF Basis Set
#'
#' Generates an HRF object using B-spline basis functions with custom parameters.
#' This is the generator function that creates HRF objects with variable numbers
#' of basis functions, unlike the pre-defined \code{HRF_BSPLINE} which has 5 functions.
#'
#' @param nbasis Number of basis functions (default: 5)
#' @param span Temporal window in seconds (default: 24)
#' @return An HRF object of class \code{c("BSpline_HRF", "HRF", "function")}
#' @seealso \code{\link{HRF_objects}} for pre-defined HRF objects,
#'   \code{\link{getHRF}} for a unified interface to create HRFs
#' @examples
#' # Create B-spline basis with 10 functions
#' custom_bs <- hrf_bspline_generator(nbasis = 10)
#' t <- seq(0, 24, by = 0.1)
#' response <- evaluate(custom_bs, t)
#' matplot(t, response, type = "l", main = "B-spline HRF with 10 basis functions")
#' @export
hrf_bspline_generator <- function(nbasis=5, span=24) {
  # Validate inputs
  if (nbasis < 1) {
    stop("nbasis must be at least 1", call. = FALSE)
  }
  if (span <= 0) {
    stop("span must be positive", call. = FALSE)
  }
  
  # Ensure nbasis is integer
  nbasis <- as.integer(nbasis)
  
  degree <- 3 # Default cubic B-splines
  effective_nbasis <- max(1, nbasis) 
  
  f_bspline <- function(t) {
    valid_t_idx <- t >= 0 & t <= span
    if (!any(valid_t_idx)) {
      return(matrix(0, nrow = length(t), ncol = effective_nbasis))
    }
    
    res_mat <- matrix(0, nrow = length(t), ncol = effective_nbasis)
    
    bs_matrix <- tryCatch({
        splines::bs(t[valid_t_idx], df = effective_nbasis, degree = degree, 
                    Boundary.knots = c(0, span), intercept = FALSE)
    }, error = function(e) {
        warning(sprintf("splines::bs failed for effective_nbasis=%d, span=%d: %s", 
                        effective_nbasis, span, e$message), call. = FALSE)
        NULL 
    })

    if (!is.null(bs_matrix) && ncol(bs_matrix) == effective_nbasis) {
      res_mat[valid_t_idx, ] <- bs_matrix
    } else if (!is.null(bs_matrix)) {
       warning(sprintf("splines::bs returned %d columns, expected %d for effective_nbasis=%d, span=%d. Returning zeros.", 
                      ncol(bs_matrix), effective_nbasis, effective_nbasis, span), call. = FALSE)
    }
    return(res_mat)
  }

  obj <- as_hrf(
    f = f_bspline,
    name = "bspline", nbasis = as.integer(effective_nbasis), span = span,
    params = list(nbasis = effective_nbasis, degree = degree, span = span)
  )
  class(obj) <- c("BSpline_HRF", class(obj))
  obj
}

hrf_tent_generator <- function(nbasis=5, span=24) {
  obj <- as_hrf(
    f = function(t) hrf_bspline(t, span=span, N=nbasis, degree=1),
    name="tent", nbasis=as.integer(nbasis), span=span,
    params=list(N=nbasis, degree=1, span=span)
  )
  class(obj) <- c("Tent_HRF", class(obj))
  obj
}

#' Create Fourier HRF Basis Set
#'
#' Generates an HRF object using Fourier basis functions (sine and cosine pairs)
#' with custom parameters.
#'
#' @param nbasis Number of basis functions (default: 5). Should be even for complete sine-cosine pairs.
#' @param span Temporal window in seconds (default: 24)
#' @return An HRF object of class \code{c("Fourier_HRF", "HRF", "function")}
#' @details 
#' The Fourier basis uses alternating sine and cosine functions with increasing
#' frequencies. This provides a smooth, periodic basis set that can capture
#' oscillatory components in the HRF.
#' @seealso \code{\link{HRF_objects}} for pre-defined HRF objects,
#'   \code{\link{getHRF}} for a unified interface to create HRFs
#' @examples
#' # Create Fourier basis with 8 functions
#' custom_fourier <- hrf_fourier_generator(nbasis = 8)
#' t <- seq(0, 24, by = 0.1)
#' response <- evaluate(custom_fourier, t)
#' matplot(t, response, type = "l", main = "Fourier HRF with 8 basis functions")
#' @export
hrf_fourier_generator <- function(nbasis=5, span=24) {
  obj <- as_hrf(
    f = function(t) hrf_fourier(t, span=span, nbasis=nbasis),
    name="fourier", nbasis=as.integer(nbasis), span=span,
    params=list(nbasis=nbasis, span=span)
  )
  class(obj) <- c("Fourier_HRF", class(obj))
  obj
}

#' Create Daguerre HRF Basis Set
#'
#' Generates an HRF object using Daguerre spherical basis functions with custom parameters.
#' These are orthogonal polynomials that naturally decay to zero.
#'
#' @param nbasis Number of basis functions (default: 3)
#' @param scale Scale parameter for the time axis (default: 4)
#' @return An HRF object of class \code{c("Daguerre_HRF", "HRF", "function")}
#' @details 
#' Daguerre basis functions are orthogonal polynomials on [0,∞) with respect
#' to the weight function w(x) = x^2 * exp(-x). They are particularly useful
#' for modeling hemodynamic responses as they naturally decay to zero and can
#' capture various response shapes with few parameters.
#' @seealso \code{\link{HRF_objects}} for pre-defined HRF objects,
#'   \code{\link{getHRF}} for a unified interface to create HRFs
#' @examples
#' # Create Daguerre basis with 5 functions
#' custom_dag <- hrf_daguerre_generator(nbasis = 5, scale = 3)
#' t <- seq(0, 24, by = 0.1)
#' response <- evaluate(custom_dag, t)
#' matplot(t, response, type = "l", main = "Daguerre HRF with 5 basis functions")
#' @export
hrf_daguerre_generator <- function(nbasis=3, scale=4) {
  obj <- as_hrf(
    f = function(t) daguerre_basis(t, n_basis=nbasis, scale=scale),
    name="daguerre", nbasis=as.integer(nbasis), span=24,
    params=list(n_basis=nbasis, scale=scale)
  )
  class(obj) <- c("Daguerre_HRF", class(obj))
  obj
}

#' Create FIR HRF Basis Set
#'
#' Generates an HRF object using Finite Impulse Response (FIR) basis functions
#' with custom parameters. Each basis function represents a time bin with a
#' value of 1 in that bin and 0 elsewhere.
#'
#' @param nbasis Number of time bins (default: 12)
#' @param span Temporal window in seconds (default: 24)
#' @return An HRF object of class \code{c("FIR_HRF", "HRF", "function")}
#' @details 
#' The FIR basis divides the time window into \code{nbasis} equal bins.
#' Each basis function is an indicator function for its corresponding bin.
#' This provides maximum flexibility but requires more parameters than
#' smoother basis sets like B-splines.
#' @seealso \code{\link{HRF_objects}} for pre-defined HRF objects,
#'   \code{\link{getHRF}} for a unified interface to create HRFs,
#'   \code{\link{hrf_bspline_generator}} for a smoother alternative
#' @examples
#' # Create FIR basis with 20 bins over 30 seconds
#' custom_fir <- hrf_fir_generator(nbasis = 20, span = 30)
#' t <- seq(0, 30, by = 0.1)
#' response <- evaluate(custom_fir, t)
#' matplot(t, response, type = "l", main = "FIR HRF with 20 time bins")
#' 
#' # Compare to default FIR with 12 bins
#' default_fir <- HRF_FIR
#' response_default <- evaluate(default_fir, t[1:241])  # 24 seconds
#' matplot(t[1:241], response_default, type = "l", 
#'         main = "Default FIR HRF (12 bins over 24s)")
#' @export
hrf_fir_generator <- function(nbasis = 12, span = 24) {
  assertthat::assert_that(
    is.numeric(nbasis) && length(nbasis) == 1 && nbasis >= 1,
    msg = "`nbasis` must be a single positive integer."
  )
  assertthat::assert_that(
    is.numeric(span) && length(span) == 1 && span > 0,
    msg = "`span` must be a single positive number."
  )
  nbasis <- as.integer(nbasis)
  bin_width <- span / nbasis

  f_fir <- function(t) {
    if (!is.numeric(t) || length(t) == 0) {
      return(matrix(0, nrow = 0, ncol = nbasis))
    }
    output_matrix <- matrix(0, nrow = length(t), ncol = nbasis)
    for (i in seq_along(t)) {
      current_t <- t[i]
      if (!is.na(current_t) && current_t >= 0 && current_t < span) {
        bin_index <- if (current_t == 0) 1 else floor(current_t / bin_width) + 1
        bin_index <- min(bin_index, nbasis) 
        output_matrix[i, bin_index] <- 1
      }
    }
    return(output_matrix)
  }

  obj <- as_hrf(
    f = f_fir,
    name = "fir",
    nbasis = nbasis,
    span = span,
    params = list(nbasis = nbasis, span = span, bin_width = bin_width)
  )
  class(obj) <- c("FIR_HRF", class(obj))
  obj
}

# Define HRF Registry -----

#' @keywords internal
HRF_REGISTRY <- list(
  spmg1    = HRF_SPMG1,
  spmg2    = HRF_SPMG2,
  spmg3    = HRF_SPMG3,
  gamma    = HRF_GAMMA,
  gaussian = HRF_GAUSSIAN,
  bspline  = hrf_bspline_generator,
  tent     = hrf_tent_generator,
  fourier  = hrf_fourier_generator,
  daguerre = hrf_daguerre_generator,
  fir      = hrf_fir_generator,
  lwu      = hrf_lwu 
)

HRF_REGISTRY$gam <- HRF_REGISTRY$gamma
HRF_REGISTRY$bs  <- HRF_REGISTRY$bspline

# getHRF function using the registry (Minimal Version) -----

#' Get HRF by Name
#'
#' Retrieves an HRF by name from the registry and optionally applies decorators.
#' This provides a unified interface for creating both pre-defined HRF objects
#' and custom basis sets with specified parameters.
#'
#' @param name Character string specifying the HRF type. Options include:
#'   \itemize{
#'     \item \code{"spmg1"}, \code{"spmg2"}, \code{"spmg3"} - SPM canonical HRFs
#'     \item \code{"gamma"}, \code{"gaussian"} - Simple parametric HRFs
#'     \item \code{"fir"} - Finite Impulse Response basis
#'     \item \code{"bspline"} or \code{"bs"} - B-spline basis
#'     \item \code{"fourier"} - Fourier basis
#'     \item \code{"daguerre"} - Daguerre spherical basis
#'     \item \code{"tent"} - Tent (linear spline) basis
#'   }
#' @param nbasis Number of basis functions (for basis set types)
#' @param span Temporal window in seconds (default: 24)
#' @param lag Time lag in seconds to apply (default: 0)
#' @param width Block width for block designs (default: 0)
#' @param summate Whether to sum responses in block designs (default: TRUE)
#' @param normalize Whether to normalize the HRF (default: FALSE)
#' @param ... Additional arguments passed to generator functions (e.g., \code{scale} for daguerre)
#' @return An HRF object
#' @details
#' For single HRF types (spmg1, gamma, gaussian), the function returns
#' pre-defined objects. For basis set types (fir, bspline, fourier, daguerre),
#' it calls the appropriate generator function with the specified parameters.
#' @examples
#' # Get pre-defined canonical HRF
#' canonical <- getHRF("spmg1")
#' 
#' # Create custom FIR basis with 20 bins
#' fir20 <- getHRF("fir", nbasis = 20, span = 30)
#' 
#' # Create B-spline basis with lag
#' bs_lag <- getHRF("bspline", nbasis = 8, lag = 2)
#' 
#' # Create blocked Gaussian HRF
#' block_gauss <- getHRF("gaussian", width = 5)
#' @export
getHRF <- function(name = "spmg1", # Default to spmg1
                   nbasis=5, span=24,
                   lag=0, width=0,
                   summate=TRUE, normalize=FALSE, ...) {

  key   <- match.arg(tolower(name), names(HRF_REGISTRY))
  entry <- HRF_REGISTRY[[key]]

  base <- if (inherits(entry, "HRF")) {
            entry # Use pre-defined object
      } else {
            # Call generator, passing nbasis, span, and any relevant ... args
            gen_args <- c(list(nbasis=as.integer(nbasis), span=span), list(...))
            # Only pass args the generator actually accepts
            valid_args <- gen_args[names(gen_args) %in% names(formals(entry))]
            do.call(entry, valid_args)
          }

  # Apply decorators
  if (width != 0) {
      stopifnot(width > 0)
      base <- block_hrf(base, width = width, summate = summate)
  }
  if (lag != 0) {
      base <- lag_hrf(base, lag = lag)
  }
  if (normalize) {
      base <- normalise_hrf(base)
  }

  attr(base, "name") <- key # Set name attribute to the matched registry key
  base
}

#' Evaluate an HRF Object
#'
#' This function evaluates a hemodynamic response function (HRF) object for a given set of time points (grid) and other parameters.
#' It handles both point evaluation (duration=0) and block evaluation (duration > 0).
#'
#' @param x The HRF object (inherits from `HRF` and `function`).
#' @param grid A numeric vector of time points at which to evaluate the HRF.
#' @param amplitude The scaling value for the event (default: 1).
#' @param duration The duration of the event (seconds). If > 0, the HRF is evaluated over this duration (default: 0).
#' @param precision The temporal resolution for evaluating responses when duration > 0 (default: 0.2).
#' @param summate Logical; whether the HRF response should accumulate over the duration (default: TRUE). If FALSE, the maximum response within the duration window is taken (currently only supported for single-basis HRFs).
#' @param normalize Logical; scale output so that the peak absolute value is 1 (default: FALSE). Applied *after* amplitude scaling and duration processing.
#' @param ... Additional arguments (unused).
#' @return A numeric vector or matrix of HRF values at the specified time points.
#' @examples
#' # Evaluate canonical HRF at specific times
#' times <- seq(0, 20, by = 0.5)
#' response <- evaluate(HRF_SPMG1, times)
#' 
#' # Evaluate with amplitude scaling
#' response_scaled <- evaluate(HRF_SPMG1, times, amplitude = 2)
#' 
#' # Evaluate with duration (block design)
#' response_block <- evaluate(HRF_SPMG1, times, duration = 5, summate = TRUE)
#' 
#' # Multi-basis HRF evaluation
#' response_multi <- evaluate(HRF_SPMG3, times)  # Returns 3-column matrix
#' @export
evaluate.HRF <- function(x, grid, amplitude = 1, duration = 0,
                         precision = .2, summate = TRUE, normalize = FALSE, ...) {

  # Validate inputs
  if (!is.numeric(grid) || length(grid) == 0 || anyNA(grid)) {
    stop("`grid` must be a non-empty numeric vector with no NA values.",
         call. = FALSE)
  }
  if (!is.numeric(precision) || length(precision) != 1 || is.na(precision) ||
      precision <= 0) {
    stop("`precision` must be a positive numeric value.", call. = FALSE)
  }

  # Base function incorporating amplitude
  base <- function(g) amplitude * x(g)

  # Evaluate based on duration
  out <- if (duration < precision) {
      # Point evaluation
    base(grid)
  } else {
      # Block evaluation
    offs <- seq(0, duration, by = precision)
      # Evaluate HRF at shifted time points for each offset
      # Use lapply to handle potential matrix output from multi-basis HRFs
      hlist <- lapply(offs, function(o) base(grid - o))
      
      # Check if the result for the first offset is a matrix (multi-basis)
      is_multi_basis <- is.matrix(hlist[[1]])
      
      if (is_multi_basis) {
          # Combine matrices (summation is standard for multi-basis)
          if (summate) {
             Reduce("+", hlist)
    } else {
             # Taking max per-basis-column across offsets is non-standard and complex.
             # Sticking to summation for multi-basis block designs.
             warning("summate=FALSE is not typically used with multi-basis HRFs during block evaluation. Using summation.", call. = FALSE)
             Reduce("+", hlist)
          }
      } else {
          # Single basis HRF: hlist contains vectors, bind them into a matrix
        hmat <- do.call(cbind, hlist)
          if (summate) {
              rowSums(hmat)
          } else {
              # For single basis, take the max across the duration window at each grid point
              apply(hmat, 1, max, na.rm = TRUE) 
              # Alternative: find which offset gives max? apply(hmat, 1, function(vals) vals[which.max(vals)])
          }
      }
  }

  # Apply normalization if requested, handling matrix/vector case
  if (normalize) {
      if (is.matrix(out)) {
          peaks <- apply(out, 2, function(col) max(abs(col), na.rm = TRUE))
          peaks[peaks == 0 | is.na(peaks)] <- 1
          out <- sweep(out, 2, peaks, "/")
      } else {
          peak_val <- max(abs(out), na.rm = TRUE)
          if (!is.na(peak_val) && peak_val != 0) out / peak_val else out
      }
  } else {
    out
  }
}

# Create pre-defined HRF objects using generators -----

#' @rdname HRF_objects
#' @export
HRF_BSPLINE <- hrf_bspline_generator(nbasis=5, span=24)

#' @rdname HRF_objects  
#' @export
HRF_FIR <- hrf_fir_generator(nbasis=12, span=24)
</file>

</files>
