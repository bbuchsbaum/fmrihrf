{"id":"manual.fmrihrf.basic_regressor","q":"How do I create an event-related fMRI regressor and evaluate its predicted BOLD time course?","a":"Use regressor() to define event onsets with an HRF, then evaluate() at your desired time grid. The default HRF is the SPM canonical (HRF_SPMG1). Amplitudes and durations can be per-event vectors.","recipe":"library(fmrihrf)\n\n# Define event onsets (seconds) for two conditions\nreg <- regressor(\n  onsets    = c(10, 30, 50, 70),\n  hrf       = HRF_SPMG1,\n  duration  = 0,          # instantaneous events\n  amplitude = c(1, 1, 1, 1)\n)\n\n# Evaluate on a fine grid (e.g. 0.1s resolution)\ntimes    <- seq(0, 100, by = 0.1)\nresponse <- evaluate(reg, times)\nplot(times, response, type = \"l\", xlab = \"Time (s)\", ylab = \"BOLD\")","symbols":["fmrihrf::regressor","fmrihrf::evaluate","fmrihrf::HRF_SPMG1"],"tags":["fmri","regressor","hrf","bold","event-related"],"package":"fmrihrf","language":"R"}
{"id":"manual.fmrihrf.sampling_frame_glm","q":"How do I sample a convolved regressor at fMRI TR acquisition times for use in a GLM design matrix?","a":"Create a sampling_frame() to describe your acquisition grid (block lengths and TR), then evaluate() the regressor using samples() to get TR-aligned time points. This gives you a column ready for a GLM.","recipe":"library(fmrihrf)\n\n# Describe a single 200-scan run at TR = 2s\nframe <- sampling_frame(blocklens = 200, TR = 2)\n\n# Get the acquisition times (at TR/2 offset by default)\nacq_times <- samples(frame)\n\n# Build regressor for two conditions\nreg_A <- regressor(onsets = c(10, 50, 90, 130), hrf = HRF_SPMG1)\nreg_B <- regressor(onsets = c(30, 70, 110, 150), hrf = HRF_SPMG1)\n\n# Evaluate at acquisition times -> design matrix columns\nX_A <- evaluate(reg_A, acq_times)\nX_B <- evaluate(reg_B, acq_times)\n\ndesign_matrix <- cbind(X_A, X_B, intercept = 1)\ncat(\"Design matrix:\", nrow(design_matrix), \"scans x\", ncol(design_matrix), \"predictors\\n\")","symbols":["fmrihrf::sampling_frame","fmrihrf::regressor","fmrihrf::evaluate","fmrihrf::samples","fmrihrf::HRF_SPMG1"],"tags":["fmri","glm","design-matrix","sampling","tr","bold"],"package":"fmrihrf","language":"R"}
{"id":"manual.fmrihrf.block_design","q":"How do I model sustained (block-design) stimuli where the neural input lasts several seconds?","a":"Use block_hrf() to convolve an HRF with a boxcar of a given width, or pass width= directly to gen_hrf(). The summate argument controls whether peak amplitude grows with duration. For block designs with variable stimulus durations, pass per-event duration values to regressor().","recipe":"library(fmrihrf)\n\n# Approach 1: create a blocked HRF object (fixed 20-second blocks)\nblock_hrf_20s <- block_hrf(HRF_SPMG1, width = 20)\n\n# Approach 2: let regressor() handle variable durations per event\nreg <- regressor(\n  onsets    = c(0, 40, 80),\n  hrf       = HRF_SPMG1,\n  duration  = c(20, 10, 15),  # each block has its own length\n  amplitude = 1,\n  summate   = TRUE             # amplitude scales with block length\n)\n\ntimes    <- seq(0, 120, by = 0.1)\nresponse <- evaluate(reg, times)\nplot(times, response, type = \"l\",\n     main = \"Block-design BOLD prediction\",\n     xlab = \"Time (s)\", ylab = \"Response\")","symbols":["fmrihrf::block_hrf","fmrihrf::gen_hrf","fmrihrf::regressor","fmrihrf::evaluate","fmrihrf::HRF_SPMG1"],"tags":["fmri","block-design","hrf","regressor","sustained"],"package":"fmrihrf","language":"R"}
{"id":"manual.fmrihrf.flexible_basis","q":"How do I use a flexible HRF basis set (FIR or B-spline) to estimate the HRF shape without assuming a canonical form?","a":"Use getHRF() with 'fir' or 'bspline' to create a multi-column basis. evaluate() then returns a matrix; each column is one basis predictor. Include all columns in your GLM and reconstruct the HRF from the estimated betas.","recipe":"library(fmrihrf)\n\n## --- FIR basis: one bin per 2-second interval, up to 24s post-onset ---\nfir_hrf <- getHRF(\"fir\", nbasis = 12, span = 24)  # 12 x 2s bins\ncat(\"FIR basis functions:\", nbasis(fir_hrf), \"\\n\")\n\n## --- B-spline basis: smoother, fewer parameters ---\nbs_hrf <- hrf_bspline_generator(nbasis = 8, span = 24)\n\n## Build regressor with FIR basis\nonsets <- c(5, 25, 45, 65, 85)\nreg    <- regressor(onsets = onsets, hrf = fir_hrf)\n\n## Evaluate on TR grid -> design matrix with 12 columns\nframe     <- sampling_frame(blocklens = 60, TR = 2)\nacq_times <- samples(frame)\nX_fir     <- evaluate(reg, acq_times)   # 60 rows x 12 columns\ncat(\"Design matrix dimensions:\", dim(X_fir), \"\\n\")\n\n## After GLM: reconstruct the estimated HRF from beta coefficients\n## betas <- coef(lm(bold ~ X_fir))[2:13]\n## t_bins <- seq(0, 22, by = 2)\n## plot(t_bins, betas, type = \"b\", main = \"Estimated HRF (FIR)\")","symbols":["fmrihrf::getHRF","fmrihrf::hrf_bspline_generator","fmrihrf::hrf_fir_generator","fmrihrf::regressor","fmrihrf::evaluate","fmrihrf::sampling_frame","fmrihrf::samples","fmrihrf::nbasis"],"tags":["fmri","hrf","fir","bspline","basis-set","flexible","estimation"],"package":"fmrihrf","language":"R"}
{"id":"manual.fmrihrf.compare_hrfs","q":"How do I compare multiple HRF shapes visually and choose the best one for my data?","a":"Use plot_hrfs() to overlay any number of HRF objects on one plot. Pass normalize=TRUE to compare shapes regardless of amplitude. list_available_hrfs() shows all built-in options.","recipe":"library(fmrihrf)\n\n# See all available HRF types\nlist_available_hrfs(details = TRUE)\n\n# Compare canonical and parametric HRFs\nplot_hrfs(\n  HRF_SPMG1,\n  HRF_GAMMA,\n  HRF_GAUSSIAN,\n  labels    = c(\"SPM Canonical\", \"Gamma\", \"Gaussian\"),\n  normalize = TRUE,\n  title     = \"HRF Shape Comparison\"\n)\n\n# Compare effect of lag on the canonical HRF\nhrf_lag0 <- HRF_SPMG1\nhrf_lag2 <- lag_hrf(HRF_SPMG1, lag = 2)\nhrf_lag4 <- lag_hrf(HRF_SPMG1, lag = 4)\n\nplot_hrfs(\n  hrf_lag0, hrf_lag2, hrf_lag4,\n  labels = c(\"No lag\", \"2s lag\", \"4s lag\"),\n  title  = \"Effect of HRF Lag\"\n)","symbols":["fmrihrf::plot_hrfs","fmrihrf::list_available_hrfs","fmrihrf::lag_hrf","fmrihrf::HRF_SPMG1","fmrihrf::HRF_GAMMA","fmrihrf::HRF_GAUSSIAN"],"tags":["fmri","hrf","visualization","comparison","lag"],"package":"fmrihrf","language":"R"}
{"id":"manual.fmrihrf.empirical_custom_hrf","q":"How do I create an HRF from my own measured or estimated data points rather than a parametric model?","a":"Use empirical_hrf() with your time points and corresponding amplitude values. It builds a linearly-interpolated HRF object that integrates with regressor() and evaluate() like any other HRF.","recipe":"library(fmrihrf)\n\n# Measured BOLD response at 1-second intervals (e.g. from a localiser run)\nt_pts  <- seq(0, 20, by = 1)\ny_vals <- c(0, 0.05, 0.3, 0.7, 1.0, 0.9, 0.6, 0.3, 0.05,\n            -0.1, -0.15, -0.1, -0.05, 0, 0, 0, 0, 0, 0, 0, 0)\n\n# Wrap as an HRF object\nemp_hrf <- empirical_hrf(t_pts, y_vals, name = \"measured_hrf\")\nprint(emp_hrf)\n\n# Evaluate on a finer grid\ntimes    <- seq(0, 22, by = 0.1)\nresponse <- evaluate(emp_hrf, times)\nplot(times, response, type = \"l\",\n     main = \"Empirical HRF\", xlab = \"Time (s)\", ylab = \"Response\")\n\n# Use directly in a regressor\nreg <- regressor(onsets = c(10, 30, 50), hrf = emp_hrf)\nacq <- samples(sampling_frame(blocklens = 100, TR = 2))\nX   <- evaluate(reg, acq)","symbols":["fmrihrf::empirical_hrf","fmrihrf::evaluate","fmrihrf::regressor","fmrihrf::sampling_frame","fmrihrf::samples"],"tags":["fmri","hrf","empirical","custom","measured"],"package":"fmrihrf","language":"R"}
